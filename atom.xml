<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ape_li</title>
  
  
  <link href="https://apelisun.github.io/atom.xml" rel="self"/>
  
  <link href="https://apelisun.github.io/"/>
  <updated>2022-08-11T13:25:58.013Z</updated>
  <id>https://apelisun.github.io/</id>
  
  <author>
    <name>ape_li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://apelisun.github.io/2022/08/11/jdbc01/"/>
    <id>https://apelisun.github.io/2022/08/11/jdbc01/</id>
    <published>2022-08-11T07:50:48.000Z</published>
    <updated>2022-08-11T13:25:58.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><blockquote><p>jdbc - java database connectivity - java数据库连接</p><p>用java编写的程序来连接的数据库的技术.jdbc是sun公司制定的一套”规范”,里面提供了大量的接口.由不同的db厂商进行实现.</p><p>而这些实现类就是驱动.</p><p>jdbc是最原始的持久层[和db交互层]的技术,属于JavaEE十三种核心技术中的一种.后期学习的持久层框架都是对jdbc的封装.</p></blockquote><h2 id="为什么要有jdbc"><a href="#为什么要有jdbc" class="headerlink" title="为什么要有jdbc"></a>为什么要有jdbc</h2><blockquote><p><code>如果没有jdbc</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlServerDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlServerDriver</span>();<span class="comment">//sqlserver</span></span><br><span class="line"></span><br><span class="line"><span class="type">MysqlDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlDriver</span>();<span class="comment">//mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java切换db比较麻烦 - 换一套连接db的代码.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sun制定jdbc规范 - 连接db的规范</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java.sql.Driver[I],不同的db厂商都是要去实现这个接口的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">Class.forName(<span class="string">"驱动类的全限定名"</span>);  <span class="comment">// 可以配置到文件中的.</span></span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><blockquote><p>为java程序访问不同的db提供统一的方式.在切换db的时候,能够做到最少改动.</p></blockquote><h2 id="相关api"><a href="#相关api" class="headerlink" title="相关api"></a>相关api</h2><blockquote><ol><li><p>java.sql.Driver[I] - 每个驱动程序类必须实现的接口.  jdbc编程第一步就是需要加载驱动[jdbc规范4.x开始可以省略不写]</p></li><li><p>java.sql.DriverManager[C] - 驱动管理类.  获取连接</p><ul><li><p>static Connection getConnection(String url,String user,String password)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user : db用户名</span><br><span class="line">password: db密码</span><br><span class="line">url: 主协议:次协议:<span class="comment">//ip地址:端口号/db名称?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>java.sql.Connection[I] - 一次会话/连接</p><ul><li>Statement createStatement();</li><li>PreparedStatement prepareStatement(String sql);//预编译语句对象</li><li>CallableStatement prepareCall();// 调用存储过程.</li></ul></li><li><p>java.sql.Statement[I] - 负责将sql语句发送到db-server端</p><ul><li>int executeUpdate(String sql);// 用于执行DML操作,insert,update,delete</li><li>ResultSet executeQuery(String sql);//用于执行DQL语句</li></ul></li><li><p>java.sql.ResultSet[I] - 结果集对象</p><p>本质上仅仅是一个游标.默认指向第一行的上方.</p><ul><li>boolean next();//1. 游标向下移动一行;2. 如果下一行没有行记录,则返回false</li><li>取列值.  String getString(int colINdex);//根据列的序号取值,第一列就是1</li><li>取列值 - String getString(String colName);//根据列的名称(支持使用别名)</li></ul></li></ol></blockquote><h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><blockquote><p>查询 - 六大编程步骤</p></blockquote><blockquote><ol><li><p>脚本</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop table jdbc_user;</span><br><span class="line">create table jdbc_user(</span><br><span class="line">    id int(7) primary key auto_increment,</span><br><span class="line">    username varchar(20) not null unique,</span><br><span class="line">    password varchar(20),</span><br><span class="line">    birthday date,</span><br><span class="line">    power int(1) comment '0-管理员,1-普通用户'</span><br><span class="line">);</span><br><span class="line">insert into jdbc_user values(1,'admin','123','2021-01-01',0);</span><br><span class="line">insert into jdbc_user values(2,'tom','123','2021-01-01',1);</span><br><span class="line">insert into jdbc_user values(3,'蔡根花','123','2021-01-02',1);</span><br></pre></td></tr></tbody></table></figure></li><li><p>实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  <span class="keyword">private</span> Integer power; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>制定持久层的接口 - IUserDao.java</p></li><li><p>制定持久层的实现类 - UserDaoImpl.java</p></li><li><p>单元测试</p></li></ol></blockquote><h1 id="Statement弊端"><a href="#Statement弊端" class="headerlink" title="Statement弊端"></a>Statement弊端</h1><blockquote><ol><li><p>参数硬拼接到了sql语句中,比较麻烦的</p></li><li><p>容易造成SQL注入 - 非法的参数/sql硬拼接到了sql语句中.</p></li><li><p>缺点 - 通过语句对象每次发送sql到db-server端,都是需要对sql语句进行编译和解析的.但是业务中可能遇到同构的sql.</p><p>同构的sql还是会多次编译和解析的,比较影响性能.</p></li><li><p>优点 - 一个statement对象可以用来多次发送不同的sql语句.</p></li></ol></blockquote><h1 id="PreparedStatement-I"><a href="#PreparedStatement-I" class="headerlink" title="PreparedStatement[I]"></a>PreparedStatement[I]</h1><blockquote><p>预编译语句对象</p><p>提前将带有占位符号的sql发送到db-server进行解析,后面只要发送参数即可.适合同构的sql</p><p>缺点: 一个pst对象,只能编译一条sql语句.</p></blockquote><h1 id="批处理效率问题"><a href="#批处理效率问题" class="headerlink" title="批处理效率问题"></a>批处理效率问题</h1><blockquote><p>addBatch(String sql);//向当前批处理中添加一条sql语句。<br>executeBatch();//执行批处理<br>clearBatch();//清空批处理</p><p>需要在url中添加rewriteBatchedStatements=true</p></blockquote><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><blockquote><ul><li><p>jdbc事务 - 由连接的db决定</p></li><li><p>jdbc事务 - 编程性事务 - 事务代码和应用程序代码耦合在一块儿的.</p></li><li><p>spring事务 - 声明式事务.事务代码(与业务无关的代码)和应用程序进行分离.</p></li><li><p>jdbc事务 - dml操作之后默认都是自动commit - executeUpdate</p></li><li><p>代码示例的结构</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try{</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line">  </span><br><span class="line">conn.commit();</span><br><span class="line">}catch(Exception e){</span><br><span class="line">  conn.rollback();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h1 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h1><p><code>针对DML</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  conn = JdbcUtil.getConnection();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//特殊的地方 - 个性的地方</span></span><br><span class="line">  pst = conn.prepareStatement(<span class="string">"delete from jdbc_user where id=?"</span>);</span><br><span class="line">  pst.setInt(<span class="number">1</span>,id);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> pst.executeUpdate();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">}<span class="keyword">finally</span> {</span><br><span class="line">  JdbcUtil.close(conn,pst);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h1><blockquote><p>结果集元数据</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;jdbc - java database connectivity - java数据库连接&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sql优化</title>
    <link href="https://apelisun.github.io/2022/08/10/sql%E4%BC%98%E5%8C%96-1/"/>
    <id>https://apelisun.github.io/2022/08/10/sql%E4%BC%98%E5%8C%96-1/</id>
    <published>2022-08-10T12:40:07.000Z</published>
    <updated>2022-08-11T00:18:04.783Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/header.jpg" alt=" "></p><h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">-- sql优化遵守原则</span><br><span class="line">-- 1.减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</span><br><span class="line">-- 2.返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘io及网络io</span><br><span class="line">-- 3.减少交互次数： 批量DML操作，函数存储等减少数据连接次数</span><br><span class="line">-- 4.减少服务器CPU开销： 尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</span><br><span class="line">-- 5.利用更多资源： 使用表分区，可以增加并行操作，更大限度利用cpu资源</span><br><span class="line"></span><br><span class="line">-- 总结到SQL优化中，就三点:</span><br><span class="line">-- 最大化利用索引；</span><br><span class="line">-- 尽可能避免全表扫描；</span><br><span class="line">-- 减少无效数据的查询；</span><br><span class="line"></span><br><span class="line">-- sql语句执行顺序</span><br><span class="line">1. select</span><br><span class="line">2. distinct &lt;select_list&gt;</span><br><span class="line">3. from &lt;left_table&gt;</span><br><span class="line">4. &lt;join_type&gt; join &lt;right_table&gt;</span><br><span class="line">5. on &lt;join_condition&gt;</span><br><span class="line">6. where &lt;where_condition&gt;</span><br><span class="line">7. group by &lt;group_by_list&gt;</span><br><span class="line">8. having &lt;having_condition&gt;</span><br><span class="line">9. order by &lt;order_by_condition&gt;</span><br><span class="line">10.limit &lt;limit_number&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- sql优化</span><br><span class="line">一、避免不走索引的场景</span><br><span class="line">1.见博客'索引'索引失效情况（以下为补充）</span><br><span class="line">2.like--被代替-&gt;instr</span><br><span class="line">3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描</span><br><span class="line">二、SELECT语句其他优化</span><br><span class="line">1. 避免出现select *</span><br><span class="line">首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。</span><br><span class="line">使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。</span><br><span class="line">建议提出业务实际需要的列数，将指定列名以取代select *。</span><br><span class="line"></span><br><span class="line">2. 避免出现不确定结果的函数</span><br><span class="line">特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。</span><br><span class="line"></span><br><span class="line">3.多表关联查询时，小表在前，大表在后。</span><br><span class="line">在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。</span><br><span class="line">例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。</span><br><span class="line"></span><br><span class="line">4. 使用表的别名</span><br><span class="line">当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。</span><br><span class="line"></span><br><span class="line">5. 用where字句替换HAVING字句</span><br><span class="line">避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。</span><br><span class="line">where和having的区别：where后面不能使用组函数</span><br><span class="line"></span><br><span class="line">6.调整Where字句中的连接顺序</span><br><span class="line">MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三、增删改 DML 语句优化</span><br><span class="line">1. 大批量插入数据</span><br><span class="line">Insert into T values(1,2),(1,3),(1,4); </span><br><span class="line">在特定场景可以减少对DB连接次数，SQL语句较短，可以减少网络传输的IO。</span><br><span class="line"></span><br><span class="line">2. 适当使用commit</span><br><span class="line">适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：</span><br><span class="line">事务占用的undo数据块；</span><br><span class="line">事务在redo log中记录的数据块；</span><br><span class="line">释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="delete和truncate的区别"><a href="#delete和truncate的区别" class="headerlink" title="delete和truncate的区别"></a>delete和truncate的区别</h1><p>1、在功能上，truncate是清空一个表的内容，它相当于delete from table_name。<br>2、delete是dml操作，truncate是ddl操作；因此，用delete删除整个表的数据时，会产生大量的roolback，占用很多的rollback segments， 而truncate不会。<br>3、在内存中，用delete删除数据，表空间中其被删除数据的表占用的空间还在，便于以后的使用，另外它是“假相”的删除，相当于windows中用delete删除数据是把数据放到回收站中，还可以恢复，当然如果这个时候重新启动系统（OS或者RDBMS），它也就不能恢复了！<br>而用truncate清除数据，内存中表空间中其被删除数据的表占用的空间会被立即释放，相当于windows中用shift+delete删除数据，不能够恢复！<br>4、truncate 调整high water mark 而delete不；truncate之后，TABLE的HWM退回到 INITIAL和NEXT的位置（默认）delete 则不可以。<br>5、truncate 只能对TABLE，delete 可以是table,view,synonym。<br>6、TRUNCATE TABLE 的对象必须是本模式下的，或者有drop any table的权限 而 DELETE 则是对象必须是本模式下的，或被授予 DELETE ON SCHEMA.TABLE 或DELETE ANY TABLE的权限。<br>7、在外层中，truncate或者delete后，其占用的空间都将释放。<br>8、truncate和delete只删除数据，而drop则删除整个表（结构和数据）。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>　　1.TRUNCATE TABLE是非常快的<br>　　2.TRUNCATE之后的自增字段从头开始计数了，而DELETE的仍保留原来的最大数值 </p><p>　　TRUNCATE  TABLE  在功能上与不带  WHERE  子句的  DELETE  语句相同：二者均删除表中的全部行。但  TRUNCATE  TABLE  比  DELETE  速度快，且使用的系统和事务日志资源少。<br>DELETE  语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE  TABLE  通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>　　TRUNCATE  TABLE  删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用  DELETE。如果要删除表定义及其数据，请使用  DROP  TABLE  语句。<br>对于由  FOREIGN  KEY  约束引用的表，不能使用  TRUNCATE  TABLE，而应使用不带  WHERE  子句的  DELETE  语句。由于  TRUNCATE  TABLE  不记录在日志中，所以它不能激活触发器。<br>　　TRUNCATE  TABLE  不能用于参与了索引视图的表。</p><h2 id="注意-这里说的delete是指不带where子句的delete语句"><a href="#注意-这里说的delete是指不带where子句的delete语句" class="headerlink" title="注意:这里说的delete是指不带where子句的delete语句"></a>注意:这里说的delete是指不带where子句的delete语句</h2><p> 相同点<br>　　truncate和不带where子句的delete, 以及drop都会删除表内的数据 </p><p>不同点:<br>\1. truncate和 delete只删除数据不删除表的结构(定义)<br>  drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态.<br>2.delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发.<br>  truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.<br>3.delete语句不影响表所占用的extent, 高水线(high watermark)保持原位置不动<br> 显然drop语句将表所占用的空间全部释放<br> truncate 语句缺省情况下见空间释放到 minextents个 extent,除非使用reuse storage;  truncate会将高水线复位(回到最开始).<br>4.速度,一般来说: drop&gt;; truncate &gt;; delete<br>5.安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及<br>使用上,想删除部分数据行用delete,注意带上where子句. 回滚段要足够大.<br>想删除表,当然用drop<br>想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete.<br>如果是整理表内部的碎片,可以用truncate跟上reuse stroage,再重新导入/</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/header.jpg&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;sql优化&quot;&gt;&lt;a href=&quot;#sql优化&quot; class=&quot;headerlink&quot; title=&quot;sql优化&quot;&gt;&lt;/a&gt;sql优化&lt;/h3&gt;&lt;figure class=&quot;hig</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>innoDB_and_myisam</title>
    <link href="https://apelisun.github.io/2022/08/10/innoDB-and-myisam/"/>
    <id>https://apelisun.github.io/2022/08/10/innoDB-and-myisam/</id>
    <published>2022-08-10T11:42:19.000Z</published>
    <updated>2022-08-10T11:42:54.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="innoDB与Myisam的区别"><a href="#innoDB与Myisam的区别" class="headerlink" title="innoDB与Myisam的区别"></a>innoDB与Myisam的区别</h3><ul><li><p><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会<strong>影响速度</strong>，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p></li><li><p><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会<strong>失败</strong>；</p></li><li><ul><li><p>3**.InnoDB是聚集索引<strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是</strong>辅助索引需要两次查询<strong>，先查询到主键，然后再通过主键查询到数据。因此，</strong>主键不应该过大，因为主键太大**，其他索引也都会-很大。</p></li><li><p>3.<strong>MyISAM是非聚集索引</strong>，也是使用B+Tree作为索引结构，<strong>索引和数据文件是分离的，</strong>索引保存的是数据文件的指针。<strong>主键索引和辅助索引是独立的</strong>。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点<strong>都是数据文件的地址指针</strong>。</p></li></ul></li><li><ol start="4"><li><strong>InnoDB不保存表的具体行数</strong>，执行select count(*) from table时需要全表扫描。<strong>而MyISAM用一个变量保存了整个表的行数</strong>，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li></ol></li><li><ol start="5"><li><strong>Innodb不支持全文索引，而MyISAM支持全文索引</strong>，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：<strong>5.7以后的InnoDB支持全文索引了</strong>**</li></ol></li><li><ol start="6"><li>MyISAM表格可以被<strong>压缩后进行查询操作</strong></li></ol></li><li><p><strong>7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></p></li><li><p>8、<strong>InnoDB表必须有唯一索引</strong>（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），<strong>而Myisam可以没有</strong></p><p>9、Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI</p><pre><code>    Innodb：frm是表定义文件，ibd是数据文件    Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</code></pre></li></ul><h3 id="如何选择："><a href="#如何选择：" class="headerlink" title="如何选择："></a>如何选择：</h3><p>​    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p><ol start="2"><li><p>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</p></li><li><p>系统奔溃后，MyISAM恢复起来更困难，能否接受；</p></li><li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差</p></li></ol><p>InnoDB为什么推荐使用自增ID作为主键？</p><p>​答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;innoDB与Myisam的区别&quot;&gt;&lt;a href=&quot;#innoDB与Myisam的区别&quot; class=&quot;headerlink&quot; title=&quot;innoDB与Myisam的区别&quot;&gt;&lt;/a&gt;innoDB与Myisam的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stro</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>储存函数触发器</title>
    <link href="https://apelisun.github.io/2022/08/09/%E5%82%A8%E5%AD%98%E5%87%BD%E6%95%B0%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://apelisun.github.io/2022/08/09/%E5%82%A8%E5%AD%98%E5%87%BD%E6%95%B0%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-08-09T13:24:55.000Z</published>
    <updated>2022-08-10T03:52:49.694Z</updated>
    
    <content type="html"><![CDATA[<p>#函数function</p><blockquote><p>mysql中内置了很多函数</p><p>mysql8.0不支持创建函数的语法的</p><p>解决方案:</p><ol><li><p>在<strong>my.ini</strong>或者my.cnf文件下添加：</p><p>[mysqld]</p><p>log-bin-trust-function-creators=1</p><p>最后mysql服务器重启</p></li></ol></blockquote><h2 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h2><blockquote><ol><li><p>函数体中一定有return语句</p></li><li><p><strong>只要遇到varchar类型,必须要指定参数的长度</strong></p></li><li><p>语法部分</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 重新定制mysql的结束符号,sql语句的结束符号默认的是分号</span><br><span class="line">delimiter $$</span><br><span class="line">         </span><br><span class="line">create function 函数名([变量名 数据类型(长度)]) returns 返回类型</span><br><span class="line">begin</span><br><span class="line">-- -- 函数体</span><br><span class="line">return 结果;</span><br><span class="line">end $$</span><br><span class="line">         </span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><p>传入俩个整数,返回俩个整数的相加的结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line">create function dy_add(a int,b int) returns int</span><br><span class="line">begin</span><br><span class="line">return a + b;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用函数</span><br><span class="line">select dy_add(50,10);</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><blockquote><p>写一个函数可以实现日期转成指定格式的字符串xxxx年xx月xx日</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">date_format(date,pattern)</span><br><span class="line"></span><br><span class="line">drop function dy_format;</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create function dy_format(dt date) returns varchar(20)</span><br><span class="line">begin</span><br><span class="line">return date_format(dt,'%Y年%m月%d日');</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select dy_format(now());</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="语句语法"><a href="#语句语法" class="headerlink" title="语句语法"></a>语句语法</h2><blockquote><ol><li><p>while..do..end while</p><p>求出1~x之间的总和</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">drop function x_add;</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create function x_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">  -- 循环变量因子,局部变量</span><br><span class="line">declare i int default 1;</span><br><span class="line">-- 定义一个变量,用来保存总的和</span><br><span class="line">declare sums int default 0;</span><br><span class="line">while i&lt;=x do</span><br><span class="line">-- 对已经声明过的变量进行赋值操作</span><br><span class="line">set sums = sums + i;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select x_add(100);</span><br></pre></td></tr></tbody></table></figure></li><li><p>分支语句if … then…end if</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  -- 求出1~x之间奇数的总和</span><br><span class="line">drop function ji_add;</span><br><span class="line">  delimiter //</span><br><span class="line">create function ji_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">declare sums int default 0;</span><br><span class="line">while i&lt;=x do</span><br><span class="line">if i%2!=0 then</span><br><span class="line">set sums = sums+i;</span><br><span class="line">end if;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ji_add(100);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><blockquote><p>求出1~x之间的数字之和,但是不包括5的倍数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">drop function my_add;</span><br><span class="line">delimiter //</span><br><span class="line">create function my_add(x int) returns int</span><br><span class="line">begin</span><br><span class="line">-- 定义一个局部变量</span><br><span class="line">declare i int default 1;</span><br><span class="line">-- 定义一个全局变量,用来存储总和</span><br><span class="line">-- 全局变量  @变量名</span><br><span class="line">-- 系统的全局变量 @@tx_isolation</span><br><span class="line">set @sums = 0;</span><br><span class="line"></span><br><span class="line">-- 对语句片段进行一个命名 - 类似于java中的continue语句</span><br><span class="line">-- 命名是任意的</span><br><span class="line">success:while i&lt;=x do</span><br><span class="line">  -- mysql中判断是否相等,=</span><br><span class="line">if i%5=0 then</span><br><span class="line">set i = i + 1;</span><br><span class="line">-- continue - 跳过本轮循环,继续下一轮循环</span><br><span class="line">iterate success;</span><br><span class="line">end if;</span><br><span class="line">set @sums = @sums + i;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">return @sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select my_add(100);</span><br><span class="line"></span><br><span class="line">-- 全局变量,在函数体外调用</span><br><span class="line">select @sums;</span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote><p>定义:为了完成一些特定的工程,提前将sql语句<strong>预编译</strong>好,存储在在mysql-server端.并且只会编译一次.后面直接调用</p><p>存储过程的时候,是不需要再次对sql语句进行编译了,提高性能.</p><p><strong>存储过程可以做到标准的组件编程[把sql封装好,形成一个组件]</strong></p></blockquote><h2 id="sql执行的过程"><a href="#sql执行的过程" class="headerlink" title="sql执行的过程"></a>sql执行的过程</h2><blockquote><ol><li>mysql-client 客户端编写sql语句 mysql&gt; select * from s_emp;</li><li>将这个客户端的sql发送到mysql-server端,需要对这条sql进行编译[检测语法]以及解析.</li><li>mysql-server将解析之后的结果返回给mysql-client;</li></ol></blockquote><blockquote><p>在没有使用存储过程之前,只要将sql语句发送到mysql-server端,每次都是需要对sql进行编译的.比较浪费时间.</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 删除存储过程</span><br><span class="line">drop procedure 存储过程名;</span><br><span class="line"></span><br><span class="line">-- 创建存储过程</span><br><span class="line">delimiter //</span><br><span class="line">create procedure 存储过程名([in|out] 变量名 数据类型)</span><br><span class="line">begin</span><br><span class="line">-- 过程体</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 把s_emp表中的员工的平均薪资预编译好在mysql-server端存储</span><br><span class="line">delimiter //</span><br><span class="line">create procedure pro_sal()</span><br><span class="line">begin</span><br><span class="line">select avg(salary) from s_emp;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call pro_sal();</span><br></pre></td></tr></tbody></table></figure><h2 id="in-接受参数"><a href="#in-接受参数" class="headerlink" title="in - 接受参数"></a>in - 接受参数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop procedure in_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure in_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">-- 输出System.out.println(a)</span><br><span class="line">-- 变量a是否有输出</span><br><span class="line">select a;</span><br><span class="line"></span><br><span class="line">-- set @i = 900,但是in来修饰的</span><br><span class="line">set a = 900;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 直接接受一个字面量</span><br><span class="line">call in_pro(10);</span><br><span class="line">-- 接受一个全局变量</span><br><span class="line">set @a=10;</span><br><span class="line">call in_pro(@a);</span><br><span class="line">-- 10</span><br><span class="line">select @a;</span><br></pre></td></tr></tbody></table></figure><h2 id="out-返回结果"><a href="#out-返回结果" class="headerlink" title="out - 返回结果"></a>out - 返回结果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop procedure out_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure out_pro(out a int)</span><br><span class="line">begin</span><br><span class="line">-- 输出System.out.println(a)</span><br><span class="line">-- out修饰的 - 不能够接受外面传进来的参数</span><br><span class="line">select a;</span><br><span class="line"></span><br><span class="line">-- 给a重新赋值 - set @i = 800</span><br><span class="line">set a = 800;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 注意点:如果参数使用out,那么此处是不允许直接使用字面量进行传参</span><br><span class="line">call out_pro(100);</span><br><span class="line">ERROR 1414 (42000): OUT or INOUT argument 1 for routine dy.out_pro is not a variable or NEW pseudo-variable in BEFORE trigger</span><br><span class="line"></span><br><span class="line">-- 只能使用全局变量进行传参</span><br><span class="line">set @i = 100;</span><br><span class="line">call out_pro(@i);</span><br><span class="line">-- 发现a为null</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| NULL |</span><br><span class="line">+------+</span><br><span class="line"></span><br><span class="line">select @i;</span><br><span class="line">+------+</span><br><span class="line">| @i   |</span><br><span class="line">+------+</span><br><span class="line">|  800 |</span><br><span class="line">+------+</span><br></pre></td></tr></tbody></table></figure><h2 id="练习-封装单个结果集"><a href="#练习-封装单个结果集" class="headerlink" title="练习 - 封装单个结果集"></a>练习 - 封装单个结果集</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><blockquote><p>根据员工的id来返回员工的名称,薪资</p><p>和表结合一起使用的话,数据类型和表统一</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop procedure find_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure find_pro(in eid int(7),out fname varchar(20),out sal float(11,2))</span><br><span class="line">begin</span><br><span class="line">select first_name into fname from s_emp where id=eid;</span><br><span class="line">select salary into sal from s_emp where id=eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call find_pro(1,@fname,@sal);</span><br><span class="line">select @fname;</span><br><span class="line">select @sal;</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><blockquote><p>统一赋值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop procedure find_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure find_pro(in eid int(7),out fname varchar(20),out sal float(11,2))</span><br><span class="line">begin</span><br><span class="line">select first_name,salary into fname,sal from s_emp where id=eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call find_pro(1,@fname,@sal);</span><br><span class="line">select @fname;</span><br><span class="line">select @sal;</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="练习-封装多个结果集"><a href="#练习-封装多个结果集" class="headerlink" title="练习 - 封装多个结果集"></a>练习 - 封装多个结果集</h2><blockquote><ol><li><p>传统的做法 - 已经被弃用了 - 性能比较低 - <strong>游标</strong></p></li><li><p>定义第三张表来存储多个结果集</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 构建临时表 - 结果集</span><br><span class="line">create table emp_copy as select first_name,salary from s_emp where 1=2;</span><br><span class="line"></span><br><span class="line">drop procedure find_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure find_pro(in eid int(7))</span><br><span class="line">begin</span><br><span class="line">insert into emp_copy(first_name,salary) select first_name,salary from s_emp where id&gt;eid;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call find_pro(20);</span><br><span class="line">select * from emp_copy;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="练习-带事务"><a href="#练习-带事务" class="headerlink" title="练习 - 带事务"></a>练习 - 带事务</h2><blockquote><p>转账功能 - 要么同时成功,要么同时失败</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">drop procedure transfer_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure transfer_pro(in sid int(7),in tid int(7),in money double(10,2),in st int(7))</span><br><span class="line">begin</span><br><span class="line">-- 定义一个局部变量,用来展示是否转账成功</span><br><span class="line">declare msg varchar(20) default '';</span><br><span class="line"></span><br><span class="line">-- 手动开启失败</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">-- 第一条sql</span><br><span class="line">update t_acc set balance = balance - money where id = sid;</span><br><span class="line"></span><br><span class="line">-- 故意搞事情</span><br><span class="line">if st=1 then</span><br><span class="line">set msg = 'sorry,转账失败!';</span><br><span class="line">-- 事务回滚</span><br><span class="line">rollback;</span><br><span class="line">else</span><br><span class="line"> -- 第二条sql</span><br><span class="line"> update t_acc set balance = balance + money where id = tid;</span><br><span class="line"> set msg = 'good,转账成功!';</span><br><span class="line">  -- 手动提交事务</span><br><span class="line">commit;</span><br><span class="line">end if;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 转账成功</span><br><span class="line">call transfer_pro(1,2,1000,2);</span><br><span class="line"></span><br><span class="line">-- 转账失败</span><br><span class="line">call transfer_pro(1,2,1000,1);</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="语句使用"><a href="#语句使用" class="headerlink" title="语句使用"></a>语句使用</h2><h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><blockquote><ol><li><p>if 条件表达式 then elseif … then … else…end if;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop procedure if_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure if_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">declare msg varchar(20) default '';</span><br><span class="line">if a&gt;=90 then</span><br><span class="line">set msg = '优秀';</span><br><span class="line">elseif a&gt;=80 then</span><br><span class="line">set msg = '良好';</span><br><span class="line">elseif a&gt;=60 then</span><br><span class="line">set msg = '中等';</span><br><span class="line">else</span><br><span class="line">set msg='不及格';</span><br><span class="line">end if;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call if_pro(85);</span><br></pre></td></tr></tbody></table></figure></li><li><p>case .. when 固定的值 then .. else .. end case</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drop procedure case_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure case_pro(in a int)</span><br><span class="line">begin</span><br><span class="line">declare msg varchar(20) default '';</span><br><span class="line">case a</span><br><span class="line">when 1 then</span><br><span class="line">set msg = '1';</span><br><span class="line">when 2 then</span><br><span class="line">set msg = '2';</span><br><span class="line">else</span><br><span class="line">set msg = '3';</span><br><span class="line">end case;</span><br><span class="line">select msg;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call case_pro(2);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><blockquote><ol><li><p>while … do .. end while</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">drop procedure while_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure while_pro(in x int,out result int) </span><br><span class="line">begin</span><br><span class="line">-- 定义一个局部变量  int i = 1</span><br><span class="line">declare i int default 1;</span><br><span class="line">-- 保存最终的总和</span><br><span class="line">declare sums int default 0;</span><br><span class="line">-- 循环</span><br><span class="line">while i&lt;=x do</span><br><span class="line">-- sums自增1</span><br><span class="line">set sums = sums + i;</span><br><span class="line">-- i应该要自增1</span><br><span class="line">set i = i + 1;</span><br><span class="line">end while;</span><br><span class="line">-- select sums;</span><br><span class="line">set result = sums;</span><br><span class="line">end //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call while_pro(100,@result);</span><br><span class="line">select @result;</span><br></pre></td></tr></tbody></table></figure></li><li><p>loop  .. end loop - 类似于java中的while(true)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 1~x</span><br><span class="line">drop procedure loop_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure loop_pro(in x int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">declare sums int default 0;</span><br><span class="line"></span><br><span class="line">success:loop</span><br><span class="line">if i&gt;x then</span><br><span class="line">-- 打破循环的语句</span><br><span class="line">-- iterate success;  类似于continue</span><br><span class="line"></span><br><span class="line">-- 类似于break</span><br><span class="line">leave success;</span><br><span class="line">end if;</span><br><span class="line">set sums = sums + i;</span><br><span class="line">set i = i + 1;</span><br><span class="line">end loop;</span><br><span class="line">select sums;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call loop_pro(100);</span><br></pre></td></tr></tbody></table></figure></li><li><p>repeat … until … end repeat</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop procedure repeat_pro;</span><br><span class="line">delimiter //</span><br><span class="line">create procedure repeat_pro(in x int)</span><br><span class="line">begin</span><br><span class="line">  -- 但是先进入到这个循环体中先执行一遍,然后再进行判断</span><br><span class="line">repeat</span><br><span class="line">set x = x + 1;</span><br><span class="line">select x;</span><br><span class="line">-- 如果x&gt;0,循环停止了</span><br><span class="line">until x&gt;0</span><br><span class="line">end repeat;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call repeat_pro(1);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h1 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h1><blockquote><ol><li>定义函数的时候,在函数的签名上必须要指定returns返回类型,定义存储过程的时候不需要使用returns来指定返回类型</li><li>函数体中必须要有return语句来返回函数的执行结果,但是存储过程中可以没有return语句</li><li>调用函数使用select,调用存储过程使用call</li><li>存储过程更加侧重于sql的封装以及sql的预编译,提高效率和安全和sql的复用性</li><li>存储过程必须要使用in来接受参数,使用out来返回结果</li></ol></blockquote><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>在myql中,当我们执行一些操作的时候,比如DML操作(触发器触发的事件),一旦事件被触发,那么</p><p>就会执行一段程序.<strong>触发器本质上就是一个特殊的存储过程.</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>after触发器 - 在触发条件之后执行</li><li>before触发器 - 在触发条件之前执行</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 删除触发器</span><br><span class="line">drop trigger 触发器名称;</span><br><span class="line">delimiter $$</span><br><span class="line">-- 创建触发器</span><br><span class="line">create trigger 触发器名</span><br><span class="line">触发时机(after,before) 触发事件(insert,delete,update) on 触发器事件所在的表名</span><br><span class="line">for each row</span><br><span class="line">-- 触发器需要执行的逻辑.</span><br><span class="line">begin</span><br><span class="line">end</span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t_acc_copy as select * from t_acc where 1=2;</span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><p>删除t_acc表中的任意一条数据之后,会在t_acc_copy表中插入一条.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop trigger acc_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger acc_tri</span><br><span class="line">after delete on t_acc</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">insert into t_acc_copy values(old.id,old.balance);</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t_acc where id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_acc_copy;</span><br><span class="line">+------+---------+</span><br><span class="line">| id   | balance |</span><br><span class="line">+------+---------+</span><br><span class="line">|    1 | 1000.00 |</span><br><span class="line">+------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure></li><li><p>级联删除 - 删除t_customer中的客户信息之前需要级联删除该客户的订单信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop trigger acc_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger cus_tri</span><br><span class="line">before delete on t_customer</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">delete from t_ord where customer_id=old.id;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">delete from t_customer where id=2;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>oracle中支持自检约束check</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table cks;</span><br><span class="line">create table cks(</span><br><span class="line">id int(7) primary key auto_increment,</span><br><span class="line">  age int(7)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into cks values(1,30);</span><br><span class="line">insert into cks values(2,30);</span><br><span class="line"></span><br><span class="line">auto_increment 主键自增长的策略,默认值是从1开始,步长为1.  主键列不需要设置值</span><br><span class="line">insert into cks(age) values(20);</span><br><span class="line">insert into cks(age) values(30);</span><br><span class="line">delete from cks where id=2;</span><br><span class="line">insert into cks(age) values(40);</span><br><span class="line">select * from cks;</span><br><span class="line"></span><br><span class="line">-- auto_increment - 主键列数据类型不能是varchar</span><br><span class="line">-- auto_increment到达最大值</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="3"><li><p>mysql用触发器来实现自检约束</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 插入age只能在(0,18]区间,否则报错.</span><br><span class="line">drop trigger cks_tri;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger cks_tri</span><br><span class="line">before insert on cks</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">if new.age&lt;0 or new.age&gt;18 then</span><br><span class="line">signal sqlstate '42000' set message_text='age必须在0~18区间';</span><br><span class="line">end if;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">insert into cks(age) values(200);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#函数function&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql中内置了很多函数&lt;/p&gt;
&lt;p&gt;mysql8.0不支持创建函数的语法的&lt;/p&gt;
&lt;p&gt;解决方案:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;strong&gt;my.ini&lt;/strong&gt;或者my.cnf文件下</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="procedure" scheme="https://apelisun.github.io/tags/procedure/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="https://apelisun.github.io/2022/08/09/B+%E6%A0%91/"/>
    <id>https://apelisun.github.io/2022/08/09/B+%E6%A0%91/</id>
    <published>2022-08-09T13:24:28.000Z</published>
    <updated>2022-08-10T13:05:52.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h1><blockquote><p>解释底层的索引的数据结构 - b+树</p></blockquote><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p> InnoDB 存储引擎中的 <em><strong>B+ 树索引</strong></em>。要介绍 B+ 树索引，就不得不提二叉查找树，</p><p>平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><p><strong>索引文件和数据文件 - innodb中 - 合二为一的 - 只有1个文件</strong></p><p><strong>索引文件和数据文件 - myisam中 - 分开独立的 - 俩个文件</strong></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img src="/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg">  </p><p><em><strong>节点(每个圆圈圈)中存储了键（key - 主键索引列）和数据（data - 每一个行记录）</strong></em>。<strong>键对应 user 表中的 id</strong>，<strong>数据对应 user 表中的行数据。</strong></p><p>二叉查找树的特点就是任何节点的<strong>左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong>。顶端的节点我们称为<strong>根节点</strong>，<strong>没有子节点的节点我们称之为<em>叶节点</em>。</strong></p><blockquote><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ol><li><p>id=12先和根节点[只有一个]key=10,发现id=12&gt;id=10 - 顺利向着根节点的右边去匹配</p></li><li><p>id=12和非叶节点id=13的进行匹配,顺利执行id=13的左边</p></li><li><p>id=12和id=12比较 - 两者是相同的.由于每个节点除了保存key还保存了value[行记录 - 行真实的行数据]</p><p>直接将这个节点的value直接取出来了.</p></li></ol><p>总结 - <strong>总共匹配了3次就可以顺利找到我们的数据.</strong></p><p><strong>如果没有创建二叉树索引.查找id=12,必然会进行全表扫描.从表的第一行向下找.最好的状态也得找6次</strong></p></blockquote><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="二叉树带来的弊端"><a href="#二叉树带来的弊端" class="headerlink" title="二叉树带来的弊端"></a>二叉树带来的弊端</h2><blockquote><p>二叉查找树的特点就是任何节点的<strong>左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong></p><p>二叉树在极端的场景下有可能成为一个链表的结构[链表的查询效率很低很低的.]</p><p>查找id=12,”链表结构”,只能从链表的头节点开始查找,最佳状态也得寻找找了5次.</p></blockquote><blockquote><p><img src="C:/Users/liming/Desktop/imgs/link.jpg"> </p></blockquote><h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2><p>为了解决这个问题[<strong>防止二叉树变成了链表结构导致查询效率依然低下</strong>]，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树.</p><p><strong>平衡二叉树又称 AVL 树</strong>，在满足二叉查找树特性的基础上，要求<strong>每个节点的左右子树的高度差不能超过 1。</strong> </p><p>下面是平衡二叉树和非平衡二叉树的对比：</p><p><img src="/diff.png"> </p><p><code>只要找到任何一个节点的左右子树高度差的绝对值大于1 - 非平衡二叉树</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点45 - 左子树高度 = 左边的子节点的个数 = 2</span><br><span class="line">- 右子树高度 = 右边没有节点 = 0</span><br><span class="line">- |高度差|=2&gt;1</span><br></pre></td></tr></tbody></table></figure><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><blockquote><p><strong>平衡二叉树暴露出来了一些缺点:</strong></p><p>每个<strong>节点仅仅保存一个key-value键值对[每个节点可保存的键值对数据太少了]</strong>.每次进行查询的时候,实际上都是需要从磁盘中读取数据的.</p><p><strong>那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块</strong></p><p>由于每个节点可保存的数据不多,仅仅保存了一个key-value.在查找数据的过程中,它就不断去和磁盘进行IO交互.</p><p>导致平衡二叉树的节点比较多.也就导致了平衡二叉树的高度比较高 - 导致比较的次数比较多 - 频繁和IO进行交互 - 查询效率低下.</p></blockquote><p><img src="/n.jpg"> </p><blockquote><p>为了解决平衡二叉树的高度太高问题.B树登场了.</p><p>B树特点</p><ol><li><p>根节点[第一页] - 永驻内存.</p></li><li><p>每个节点可以保存多个key-value - 导致子节点也会增多.B树又矮又胖.</p></li><li><p>没有子节点的节点 - 叶节点,有子节点的节点 - 非叶节点</p></li><li><p>B树的m阶 - m值就是看它最大的子节点的个数 - 3 , 下面的图代表的就是3阶b树.</p><p>如果有10亿条数据,<strong>只需要和磁盘进行交互2次.把磁盘块中的一页数据[16kb]全部加载到内存中.</strong></p></li><li><p>页page的概念 - 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块</p><p>读取的单位是 - 页 - 1页的磁盘块的数据大小是<strong>16kb</strong>,每个节点可以更多的key-value</p></li><li><p><strong>页与也之间是一个链表的结构</strong></p></li><li><p>查找id=28的数据 - 磁盘交互了3次</p><p>①id=28到第一页中进行匹配,发现id=28在17和35之间,获取p2指针.p2指向到页3</p><p>②定位到页3,发现id=28在26~30之间,继续拿到p2指针,p2指向的是页8</p><p>③定位到页8,顺利匹配查找到id=28这条数据</p></li></ol></blockquote><p><img src="/b.jpg"> </p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><blockquote><p>是Innodb和myisam存储引擎中索引底层的数据结构 - B+树</p><p>B树中每个节点中不仅仅存储key[索引列值,主键列值],还存储了数据.因为数据库中的页的大小是固定的[Innodb默认是16kb],</p><p>导致每个节点的存储资源有点浪费了.</p></blockquote><blockquote><p>B+树和B树的重要区别就是</p><ol><li><p><strong>B+树中非叶节点,仅仅保存了key值[索引列,主键列值],没有保存数据.每个非叶节点可以保存更多的key</strong></p></li><li><p>B+树中索引的所有的数据都放在了叶子节点中,而且是<strong>按照顺序排列的.</strong></p></li></ol></blockquote><blockquote><ol start="3"><li>**页与页之间是双向链表结构,**叶节点中的每个数据节点单向链表</li><li>下面这个图展示的是Innodb中的索引的结构.并不是Myisam中索引的结构</li><li>以下图示本质上就是<strong>聚簇索引[主键列索引]的方式 - key - 主键列</strong></li></ol></blockquote><p><img src="/B+.jpg"> </p><h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。</p><p>那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。</p><p>这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><ul><li><p>聚集索引（聚簇索引）：<em><strong>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</strong></em></p><p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，<strong>在 B+ 树的叶子节点中，存储了表中所有的数据。</strong></p><p><strong>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</strong></p></li><li><p>非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于<em><strong>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键</strong></em>，想要<strong>查找数据我们还需要根据主键再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<em><strong>回表</strong></em>。</p></li></ul><h2 id="聚簇索引存储和查找"><a href="#聚簇索引存储和查找" class="headerlink" title="聚簇索引存储和查找"></a>聚簇索引存储和查找</h2><blockquote><ol><li>先到非叶节点找到索引列所在的页位置</li><li>根据页位置定位到叶节点的位置</li><li>叶节点中根据索引列的值找出数据</li></ol></blockquote><p><img src="/jusearch.jpg" alt="B+树"> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from xx where id&gt;=18 and id&lt;41;</span><br><span class="line">-- 聚簇索引的查找方式 - 根据主键列id列进行查找的流程</span><br><span class="line">1. 先从页1中看id的区间,定位到p2-&gt;页3</span><br><span class="line">2. 定位到页3,定位到p1-&gt;页8[叶节点-单向链表 - 查找必须从头节点开始找]</span><br><span class="line">3. 依次按照链表的顺序一致找到id开始&lt;41的这个节点.满足条件的叶节点中的数据全部查出来 [叶节点中保存了真实的数据]</span><br></pre></td></tr></tbody></table></figure><h2 id="非聚簇索引存储和查找"><a href="#非聚簇索引存储和查找" class="headerlink" title="非聚簇索引存储和查找"></a>非聚簇索引存储和查找</h2><blockquote><p>B+树的结构</p><p>表结构:<strong>id</strong> age <strong>name</strong></p><p>id - 主键列 - 默认是聚簇索引列 - 主键列</p><p>name - <strong>非聚簇索引列 - 索引列 - 辅助索引</strong></p></blockquote><blockquote><p><img src="/x.png"> </p></blockquote><blockquote><p>非聚簇索引 - 非主键列索引 - <strong>name列创建了索引</strong> - 辅助索引.</p></blockquote><blockquote><p>结构:</p><ol><li><p>根节点 - 一页数据 - 非聚簇索引列值 - name</p></li><li><p>非叶节点 - 非聚簇索引列值</p></li><li><p><strong>页节点存储的东西 - name索引列以及该列对应的主键列值.</strong> - <strong>这是和聚簇索引最大的一个不同点</strong></p><p>它和聚簇索引最大的区别是页节点中没有存储最终的数据.而是存储的是键值对x-y</p><p>x就是非聚簇索引列值,y是对应的主键列值.</p></li></ol></blockquote><blockquote><p>非聚簇索引的查找方式:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx where name='Bob';</span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><p>按照B+树的查找流程 - 确认name=’Bob’的具体位置</p></li><li><p>由于非聚簇索引的结构中叶节点仅仅保存了name-主键列值</p></li><li><p>先根据name=’Bob’这个条件找到对应的主键列值id=15</p></li><li><p><strong>要进行”回表操作”</strong></p><p><img src="/y.png"></p></li></ol></blockquote></blockquote><blockquote><blockquote><ol start="5"><li><p>继续拿着主键列id=15到索引的结构中继续查找一次 - “一次回表查找”.</p><p>id也是聚簇索引 - B+树的结构 - 叶子节点中存储的就是数据.</p><p>根据聚簇索引列的查找方式 - id=15的叶节点 - 拿到里面的数据</p></li></ol></blockquote></blockquote><h2 id="非聚簇索引列查找一定会回表"><a href="#非聚簇索引列查找一定会回表" class="headerlink" title="非聚簇索引列查找一定会回表?????"></a>非聚簇索引列查找一定会回表?????</h2><blockquote><p><strong>未必</strong> - 因为非叶节点中存储的就是索引列值.</p><p>查询</p><p>select id from xxx where name=’Bob’;<br>select name from xxx where name=’Bob’;</p><p>不需要回表了.这条语句查询的结果name已经在非聚簇索引的非叶节点中保存了.</p></blockquote><blockquote><p>回表 </p><ol><li><p>根据一个非聚簇索引列查找 - 优先先到非聚簇索引的B+树中找到该列对应的主键列值[聚簇索引列值]</p></li><li><p>再拿着这个聚簇索引列的值再去到聚簇索引列的B+树中再查找一次</p></li></ol></blockquote><h1 id="myisam中的索引特点"><a href="#myisam中的索引特点" class="headerlink" title="myisam中的索引特点"></a>myisam中的索引特点</h1><blockquote><p>索引的本质就是一个键值对key-value</p><p><strong>key - 索引列值,value - 数据行的物理地址.</strong></p><p>主键列索引/辅助索引 -&gt; 两颗独立的B+树,都是索引列值对应的行记录的物理地址.</p></blockquote><blockquote><ol><li><p>innodb中索引和数据合并到一个文件中</p></li><li><p>myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件.</p></li><li><p>myisam中采用的是”非聚集的方式”</p></li><li><p>无论是聚簇索引还是非聚簇索引,查找方式是一样.</p></li><li><p>采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.**</p><p>需要再根据行记录地址到表中进行定位[回表]</p></li></ol></blockquote><blockquote><p><img src="/img/z.jpg"> </p></blockquote><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主键列 - key是不允许重复的</span><br><span class="line">非主键列 - key是允许重复的.</span><br><span class="line">select * from xxx where id=5;</span><br><span class="line"></span><br><span class="line">1. 先到B+树找到找到id=5对应的节点 - 取出里面的行记录的物理地址0x6a</span><br><span class="line">2. 回表 - 直接根据行记录的物理地址直接定位到具体的一行.</span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引底层原理&quot;&gt;&lt;a href=&quot;#索引底层原理&quot; class=&quot;headerlink&quot; title=&quot;索引底层原理&quot;&gt;&lt;/a&gt;索引底层原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;解释底层的索引的数据结构 - b+树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 </summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="B+树" scheme="https://apelisun.github.io/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>sql习题1</title>
    <link href="https://apelisun.github.io/2022/08/09/sql%E4%B9%A0%E9%A2%981/"/>
    <id>https://apelisun.github.io/2022/08/09/sql%E4%B9%A0%E9%A2%981/</id>
    <published>2022-08-09T13:23:45.000Z</published>
    <updated>2022-08-10T03:52:13.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现有一个商店的数据库，记录顾客及其购物情况，由下面三个表组成：</p><ol><li>商品product（商品号productid  int(7)]，<br>商品名productname [varchar(128)]，<br>     单价unitprice int(11,2)，<br>     商品类别category[varchar(28)]，<br>     供应商provider [varchar(48)]）；<br> 主键：productid</li><li>顾客customer（顾客号customerid int(7)]，<br>姓名name[varchar(48)]，<br>     住址location[varchar(128)]）；<br> 主键：customerid</li><li>购买purcase（顾客号customerid，商品号productid，<br>购买数量quantity[int(7)]）；<br> 外键：customerid  引用 客户表的 customerid<br> 外键：productid  引用 产品表的 productid<br> 主键：(customerid, productid)   –&gt; 联合主键</li></ol></blockquote><blockquote><p><strong>任务一:使用DDL语言创建上面的表,并且设置必要的主键约束和外键约束</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">drop table product;</span><br><span class="line">create table product(</span><br><span class="line">productid int(7) primary key,</span><br><span class="line">productname varchar(128),</span><br><span class="line">unitprice double(11,2),</span><br><span class="line">catagory varchar(28),</span><br><span class="line">provider varchar(48)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drop table customer;</span><br><span class="line">create table customer(</span><br><span class="line">customerid int(7) primary key,</span><br><span class="line">name varchar(48),</span><br><span class="line">location varchar(128)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">drop table purcase;</span><br><span class="line">create table purcase(</span><br><span class="line">customerid int(7),</span><br><span class="line">productid  int(7),</span><br><span class="line">quantity int(7),</span><br><span class="line">constraint purcase_id_pk primary key(customerid,productid),</span><br><span class="line">constraint purcase_id1_fk foreign key(productid) references product(productid),</span><br><span class="line">constraint purcase_id2_fk foreign key(customerid) references customer(customerid)   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into product values(1,'佳洁士',8.00,'牙膏','宝洁'),(2,'高露洁',6.50,'牙膏','高露洁'),</span><br><span class="line">(3,'洁诺',5.00,'牙膏','联合利华'),</span><br><span class="line">(4,'舒肤佳',3.00,'香皂','宝洁'),</span><br><span class="line">(5,'夏士莲',5.00,'香皂','联合利华'),</span><br><span class="line">(6,'雕牌',2.50,'洗衣粉','纳爱斯'),</span><br><span class="line">(7,'中华',3.50,'牙膏','联合利华'),</span><br><span class="line">(8,'汰渍',3.00,'洗衣粉','宝洁'),</span><br><span class="line">(9,'碧浪',4.00,'洗衣粉','宝洁');</span><br><span class="line"></span><br><span class="line">insert into customer values(1,'Dennis','黄浦区'),</span><br><span class="line">(2,'John','徐家汇'),</span><br><span class="line">(3,'Tom','闸北'),</span><br><span class="line">(4,'Jenny','静安'),</span><br><span class="line">(5,'Rick','浦东');</span><br><span class="line"></span><br><span class="line">insert into purcase values(1,1,3),     </span><br><span class="line">(1,5,2),</span><br><span class="line">(1,8,2) ,   </span><br><span class="line">(2,2,5),</span><br><span class="line">(2,6,4) ,    </span><br><span class="line">(3,1,1),</span><br><span class="line">(3,5,1 ),    </span><br><span class="line">(3,6,3),</span><br><span class="line">(3,8,1 ),    </span><br><span class="line">(4,3,7),</span><br><span class="line">(4,4,3 ),    </span><br><span class="line">(5,6,2),</span><br><span class="line">(5,7,8);</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p><strong>任务二: 向对应的表中插入如下数据</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">商品（1，佳洁士，8.00，牙膏，宝洁；</span><br><span class="line">   2，高露洁，6.50，牙膏，高露洁；</span><br><span class="line">   3，洁诺，5.00，牙膏，联合利华；</span><br><span class="line">   4，舒肤佳，3.00，香皂，宝洁；</span><br><span class="line">   5，夏士莲，5.00，香皂，联合利华；</span><br><span class="line">   6，雕牌，2.50，洗衣粉，纳爱斯</span><br><span class="line">   7，中华，3.50，牙膏，联合利华；</span><br><span class="line">   8，汰渍，3.00，洗衣粉，宝洁；</span><br><span class="line">   9，碧浪，4.00，洗衣粉，宝洁；）</span><br><span class="line">顾客（1，Dennis，黄浦区；</span><br><span class="line">   2，John，徐家汇；</span><br><span class="line">   3，Tom，闸北；</span><br><span class="line">   4，Jenny，静安；</span><br><span class="line">   5，Rick，浦东；） </span><br><span class="line">购买(1，1，3；     </span><br><span class="line">  1，5，2；</span><br><span class="line">  1，8，2；     </span><br><span class="line">  2，2，5；</span><br><span class="line">  2，6，4；     </span><br><span class="line">  3，1，1；</span><br><span class="line">  3，5，1；     </span><br><span class="line">  3，6，3；</span><br><span class="line">  3，8，1；     </span><br><span class="line">  4，3，7；</span><br><span class="line">  4，4，3；     </span><br><span class="line">  5，6，2；</span><br><span class="line">  5，7，8；）</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p><strong>任务三: 完成如下语句</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">（1）求购买了供应商"宝洁"产品的所有顾客；</span><br><span class="line">select distinct c.customerid,c.name from customer c join purcase p on p.customerid=c.customerid where p.productid  in (select pr.productid from product pr where pr.provider='宝洁');</span><br><span class="line">+------------+--------+</span><br><span class="line">| customerid | name   |</span><br><span class="line">+------------+--------+</span><br><span class="line">|          1 | Dennis |</span><br><span class="line">|          3 | Tom    |</span><br><span class="line">|          4 | Jenny  |</span><br><span class="line">+------------+--------+</span><br><span class="line">（2）求购买的商品包含了顾客"Dennis"所购买的所有商品的顾客（姓名）</span><br><span class="line">select p2.customerid from purcase p2 where p2.productid in (select p.productid from customer c join purcase  p on c.customerid=p.customerid where c.name='Dennis') and customerid&lt;&gt;(select distinct p4.customerid from customer c4 join purcase p4 on p4.customerid=c4.customerid where c4.name="Dennis") group by p2.customerid having count(*)&gt;=(select count(*) from customer c2 join purcase p3  on c2.customerid=p3.customerid where c2.name='Dennis');</span><br><span class="line">+------------+</span><br><span class="line">| customerid |</span><br><span class="line">+------------+</span><br><span class="line">|          3 |</span><br><span class="line">+------------+</span><br><span class="line">（3）求牙膏卖出数量最多的供应商。</span><br><span class="line">select pr.provider,sum(pu1.quantity) from product pr join purcase pu1 on pu1.productid=pr.productid and pr.catagory='牙膏' GROUP BY pr.provider order by sum(pu1.quantity) desc limit 1;</span><br><span class="line">+--------------+-------------------+</span><br><span class="line">| provider     | sum(pu1.quantity) |</span><br><span class="line">+--------------+-------------------+</span><br><span class="line">| 联合利华     |                15 |</span><br><span class="line">+--------------+-------------------+</span><br><span class="line"></span><br><span class="line">(4)将所有的牙膏商品单价增加10%。</span><br><span class="line">update product set unitprice=unitprice*1.1 where catagory='牙膏';</span><br><span class="line"></span><br><span class="line">(5)删除从未被购买的商品记录。</span><br><span class="line">delete from product where productid  not in (select pu.productid from purcase pu);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;现有一个商店的数据库，记录顾客及其购物情况，由下面三个表组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;商品product（商品号productid  int(7)]，&lt;br&gt;商品名productname [varchar(128)]，&lt;br&gt;     单价un</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="homework" scheme="https://apelisun.github.io/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>mysql3</title>
    <link href="https://apelisun.github.io/2022/08/09/mysql3/"/>
    <id>https://apelisun.github.io/2022/08/09/mysql3/</id>
    <published>2022-08-09T13:23:13.000Z</published>
    <updated>2022-08-10T03:49:53.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DB设计"><a href="#DB设计" class="headerlink" title="DB设计"></a>DB设计</h1><blockquote><p>指导db设计的思想,避免表中出现大量的冗余的数据.但是实际开发中表中是允许出现冗余的字段的.</p><p>冗余数据的好处 - 安全,方便查询.坏处-&gt;delete和update操作</p></blockquote><blockquote><ol><li><p>1NF - 第一范式-保证列的原子性,保证列不可再切割</p><p>s_emp(id,name) - 发现name不具备原子性,可以被再次切割(fist_name,last_name)</p><p>s_ord(id,address) - address显示为省市区 - 江苏省苏州市园区</p><p>address再次分成(province,city,area)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主要是为了查询.</span><br><span class="line"></span><br><span class="line">select * from s_ord where address like '%苏州%';</span><br><span class="line"></span><br><span class="line">select * from s_ord where city = '苏州';</span><br><span class="line"></span><br><span class="line">-- address,city加索引.</span><br><span class="line">-- 模糊查询可能导致索引失效.但是精确匹配是走索引的.</span><br></pre></td></tr></tbody></table></figure></li><li><p>2NF - 基于1NF,要求非关键列要全部依赖于关键列.  不存在非关键列部分依赖于关键列</p><p>关键列 - 主键列 - 非空且唯一 - table中的id设置成主键列.</p><p>student(sid,sname,cid,cname);//关键列(sid,cid) - 确定唯一的元组(行) - 复合主键</p><p>sname,cname - 非关键列.</p><p>(sid,cid) -&gt; 唯一确定 -&gt; sname/cname</p><p>sid -&gt; sname,cid -&gt; cname</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student(sid,sname)</span><br><span class="line">course(cid,cname);</span><br><span class="line">sc(sid,cid,kpi);//(sid,cid) -&gt; kpi</span><br></pre></td></tr></tbody></table></figure></li><li><p>3NF- 基于2NF,要求非关键列不能传递依赖于关键列.</p><p>student(sid,sname,uid,uv_name,u_phone);</p><p>u_phone传递依赖于sid - <code>原因sid -&gt; uid -&gt; u_phone</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student(sid,sname,uid);//uid就是foreign key 外键列</span><br><span class="line">university(uid,u_name,u_phone);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li>用户表t_user</li><li>视频表t_video</li><li>评论表和回复表设计</li></ol></blockquote><blockquote><p>用户对视频进行评论(t_comment)和回复(t_repy)的场景:</p><p>tom 发布了 搞笑的视频</p><p>admin 评论:  😁😎</p><p>​             li评论admin: 你笑什么!</p><p>​ lei回复@li: 管你什么事情!</p><p>​ x回复@li: 你想表达什么!</p><p>​ y回复@x: ….</p><p>​ k 评论admin:你笑什么!</p><p>jack  评论: 😄</p></blockquote><p><code>t_user</code></p><table><thead><tr><th>id</th><th>usernmae</th><th></th></tr></thead><tbody><tr><td>1</td><td>tom</td><td></td></tr><tr><td>2</td><td>admin</td><td></td></tr><tr><td>3</td><td>li</td><td></td></tr><tr><td>4</td><td>lei</td><td></td></tr><tr><td>5</td><td>x</td><td></td></tr><tr><td>6</td><td>y</td><td></td></tr><tr><td>7</td><td>k</td><td></td></tr></tbody></table><p><code>t_video</code></p><p>一个用户可以发布多个视频</p><table><thead><tr><th>id</th><th>video</th><th>user_id</th></tr></thead><tbody><tr><td>1</td><td>佩洛西</td><td>1</td></tr></tbody></table><p><code>t_comment</code></p><table><thead><tr><th>id</th><th>video_id</th><th>content</th><th>comment_id</th><th>user_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>😁😎</td><td></td><td>2</td></tr><tr><td>2</td><td>1</td><td>你笑什么!</td><td>1</td><td>3</td></tr><tr><td>3</td><td>1</td><td>你笑什么!</td><td>1</td><td>7</td></tr></tbody></table><p><code>t_reply</code></p><table><thead><tr><th>id</th><th>comment_id</th><th>conent</th><th>reply_id</th><th>user_id</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>管你什么事情!</td><td></td><td>4</td></tr><tr><td>2</td><td>2</td><td>你想表达什么!</td><td></td><td>5</td></tr><tr><td>3</td><td>2</td><td>…</td><td>2</td><td>6</td></tr></tbody></table><h1 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h1><blockquote><p>Data Definition Language - 数据定义语言.</p><p>包括的命令:create drop alter comment rename truncate</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><ol><li><p>数字类型</p><ul><li>整数 - int/bigint</li><li>小数 - float/double/decimal</li></ul><p><code>要点</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">id int(7)</span><br><span class="line">);</span><br><span class="line">此处的7并不是代表此列的最大长度.误区:最大可保存的值是9999999</span><br><span class="line">实际上该列可以存储的最大值是由类型决定了.</span><br><span class="line"></span><br><span class="line">配置zerofill  0填充</span><br><span class="line">create table t_type(</span><br><span class="line">id int(7) zerofill</span><br><span class="line">);</span><br><span class="line">insert into t_type values(1);</span><br><span class="line"></span><br><span class="line">不足7位,会采用0来填充</span><br><span class="line"></span><br><span class="line">+---------+</span><br><span class="line">| id      |</span><br><span class="line">+---------+</span><br><span class="line">| 0000001 |</span><br><span class="line">+---------+</span><br><span class="line"></span><br><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">c1 float(5,2),</span><br><span class="line">  c2 double(5,2),</span><br><span class="line">  c3 decimal(5,2)</span><br><span class="line">);</span><br><span class="line">float(m,n) =&gt; m总长度,n代表的小数点</span><br><span class="line">insert into t_type(c1) values(12.345);</span><br><span class="line">mysql&gt; select * from t_type;</span><br><span class="line"></span><br><span class="line">-- 小数保留2位,并且四舍五入</span><br><span class="line">+-------+------+------+</span><br><span class="line">| c1    | c2   | c3   |</span><br><span class="line">+-------+------+------+</span><br><span class="line">| 12.35 | NULL | NULL |</span><br><span class="line">+-------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_type(c2) values(123.5); //ok</span><br><span class="line">mysql&gt; select * from t_type;</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| c1    | c2     | c3   |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| 12.35 |   NULL | NULL |</span><br><span class="line">|  NULL | 123.50 | NULL |</span><br><span class="line">+-------+--------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_type(c2) values(1234.5);</span><br><span class="line"></span><br><span class="line">`原因:1234.5 =&gt; 1234.50 已经超过5位了`</span><br><span class="line">ERROR 1264 (22003): Out of range value for column 'c2' at row 1</span><br><span class="line"></span><br><span class="line">float/double =&gt; 非标准  decimal标准 - 对精度有特别要求的</span><br><span class="line"></span><br><span class="line">insert into t_type(c3) values(123.589);</span><br></pre></td></tr></tbody></table></figure></li><li><p>关于日期类型</p><p>date </p><p>datetime</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">  id int,</span><br><span class="line">create_date date default now()</span><br><span class="line">);</span><br><span class="line">ERROR 1067 (42000): Invalid default value for 'create_date'</span><br><span class="line"></span><br><span class="line">如果某个列期望默认值是now(),一定要设置成datetime</span><br><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">  id int,</span><br><span class="line">create_date datetime default now()</span><br><span class="line">);</span><br><span class="line">insert into t_type(id) values(1);</span><br><span class="line"></span><br><span class="line">-- 满足日期能够支持的字符串格式</span><br><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">  id int,</span><br><span class="line">create_date date default '2012-09-08 12:12:12'</span><br><span class="line">);</span><br><span class="line">insert into t_type(id) values(1);</span><br></pre></td></tr></tbody></table></figure></li><li><p>字符串类型</p><ul><li><p>char和varchar区别</p><p>char(n),varchar(n) =&gt; 代表的字符的个数</p><p>区别: char是定长,varchar是可变长.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">   s1 char(2),</span><br><span class="line">   s2 varchar(2)</span><br><span class="line">);</span><br><span class="line">insert into t_type(s1) values('ab');</span><br><span class="line"></span><br><span class="line">insert into t_type(s2) values('abc');</span><br><span class="line"></span><br><span class="line">char(2) =&gt; 实际存储1个'a',实际消耗了2个</span><br><span class="line">varchar(2) =&gt; 假设'a',实际仅仅消耗了1个,最大消耗2个.</span><br><span class="line">varchar更加节约空间.  char效率会更高一点 - 不推荐用char</span><br><span class="line"></span><br><span class="line">-- oracle中数据中</span><br><span class="line">drop table t_type;</span><br><span class="line">create table t_type(</span><br><span class="line">   s1 char(2)</span><br><span class="line">);</span><br><span class="line">insert into t_type(s1) values('a');</span><br><span class="line"></span><br><span class="line">-- oracle查询为empty</span><br><span class="line">-- mysql中空直接比较的时候剔除,大小写比较都是一样的.</span><br><span class="line">select * from t_type where s1='a';</span><br></pre></td></tr></tbody></table></figure></li><li><p>text - 0-65 535 bytes - 长文本</p></li></ul></li></ol></blockquote><h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><blockquote><ol><li><p>主键约束 primary key 非空且唯一</p><p>主键列可以是由多列共同组成 - 符合主键列</p><p>但是表中只能出现一个主键</p></li><li><p>外键约束 foreign key </p><ul><li><p>外键列允许为null</p></li><li><p>外键列是多出现在多的一方中.建立表与表之间的关系的</p></li><li><p>开发中不需要设置外键 - 造成表与表之间的耦合. </p><p>表和表之间的关系是在”心中”!</p></li></ul></li><li><p>非空约束 - not null</p></li><li><p>唯一约束 - unique</p></li><li><p>default - 默认值</p></li><li><p>mysql中不支持自检约束,oracle中支持的check检查约束.但是mysql中可以使用触发器来实现.</p></li></ol></blockquote><h1 id="创建表语法"><a href="#创建表语法" class="headerlink" title="创建表语法"></a>创建表语法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP table 表名;</span><br><span class="line">-- 约束列级添加</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型(n) 约束类型 COMMNET '注释',</span><br><span class="line">  列名 数据类型(n) 约束类型 COMMNET '注释'</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">engine 指定存储引擎,默认的就是innodb(外键约束,事务,行锁,表锁)</span><br><span class="line">之前的版本应该是myisam(仅仅支持表锁)</span><br><span class="line"></span><br><span class="line">-- 约束表级</span><br><span class="line">-- 约束命名规范:表名_列名_约束类型缩写</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型(n) COMMNET '注释',</span><br><span class="line">  列名 数据类型(n) COMMNET '注释',</span><br><span class="line">  [CONSTRAINT 约束名称] 约束类型(列名),</span><br><span class="line">  [CONSTRAINT 约束名称] 约束类型(列名)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h2 id="列级添加方式"><a href="#列级添加方式" class="headerlink" title="列级添加方式"></a>列级添加方式</h2><blockquote><p>直接在列的后面的增加关于该列的约束</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">username varchar(20) unique not null,</span><br><span class="line">birthday date default '1991-09-08'</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_user(id) values(1);</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="表级添加方式"><a href="#表级添加方式" class="headerlink" title="表级添加方式"></a>表级添加方式</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">-- not null仅仅支持列级添加</span><br><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int(7),</span><br><span class="line">  username varchar(20) not null,</span><br><span class="line"> birthday date,</span><br><span class="line">  constraint t_user_id_pk primary key(id),</span><br><span class="line">  constraint t_user_username_uq unique(username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 约束名 - 提高错的可读性</span><br><span class="line">insert into t_user(id) values(1);</span><br><span class="line"></span><br><span class="line">-- 数据字典 - 描述表的表</span><br><span class="line">-- 数据字典就是用来存放用户信息/用户创建的这表的信息.</span><br><span class="line">show tables;</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">-- 使用系统自带的数据库mysql</span><br><span class="line">use information_schema</span><br><span class="line"></span><br><span class="line">-- TABLE_CONSTRAINTS 表名 - 数据字典 - 专门存储每个用户的表的约束信息</span><br><span class="line">desc table_constraints</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field              | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">| CONSTRAINT_CATALOG | varchar(512) | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_SCHEMA  | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_NAME    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA       | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME         | varchar(64)  | NO   |     |         |       |</span><br><span class="line">| CONSTRAINT_TYPE    | varchar(64)  | NO   |     |         |       |</span><br><span class="line">+--------------------+--------------+------+-----+---------+-------+</span><br><span class="line">CONSTRAINT_NAME - 约束名称</span><br><span class="line">TABLE_NAME - 表名</span><br><span class="line">CONSTRAINT_TYPE - 约束类型</span><br><span class="line"></span><br><span class="line">-- 查询出T_USER表中的约束信息</span><br><span class="line">select constraint_name,constraint_type,table_name from table_constraints</span><br><span class="line">where table_name='T_USER' and table_schema='dy';</span><br><span class="line"></span><br><span class="line">-- 查询t_user表中的所有的列的名称以及列的数据类型</span><br><span class="line">select column_name,column_type,data_type,column_key from columns where table_schema='dy' and table_name='t_user';</span><br></pre></td></tr></tbody></table></figure><h2 id="建表的其他语法"><a href="#建表的其他语法" class="headerlink" title="建表的其他语法"></a>建表的其他语法</h2><blockquote><ol><li><p>利用一张已经存在的表来构建另外一张表</p><ul><li><p>保留原来表中的数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int(7),</span><br><span class="line">  username varchar(20) not null,</span><br><span class="line"> birthday date,</span><br><span class="line">  constraint t_user_id_pk primary key(id),</span><br><span class="line">  constraint t_user_username_uq unique(username)</span><br><span class="line">);</span><br><span class="line">insert into t_user values(1,'tom','2021-09-08');</span><br><span class="line">insert into t_user values(2,'jack','2022-09-08');</span><br><span class="line"></span><br><span class="line">-- 克隆</span><br><span class="line">CREATE TABLE 表名 AS SELECT查询语句;</span><br><span class="line"></span><br><span class="line">create table t_user_copy as select * from t_user;</span><br></pre></td></tr></tbody></table></figure></li><li><p>保留原表的结构,但是不保留数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop table t_user_copy;</span><br><span class="line">     </span><br><span class="line">create table t_user_copy as select * from t_user where 1=2;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol></blockquote><blockquote><ol start="2"><li><p>查看建表语句-DDL</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果是一个1:n</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table t_ord;</span><br><span class="line">drop table t_customer;</span><br><span class="line">create table t_customer(</span><br><span class="line">id int(7),</span><br><span class="line">  cname varchar(20) not null,</span><br><span class="line">  constraint t_customer_id_pk primary key(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table t_ord(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  ord_no varchar(20) not null unique,</span><br><span class="line">  total double(7,2),</span><br><span class="line">  customer_id int(7),</span><br><span class="line">  constraint t_ord_customer_id_fk foreign key(customer_id) references t_customer(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 一定是父级表t_customer</span><br><span class="line">-- 删表 - 先删除子表,多的一方,外键所在的那张表.</span><br></pre></td></tr></tbody></table></figure></li><li><p>n:n</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop table t_sc;</span><br><span class="line">drop table t_student;</span><br><span class="line">drop table t_course;</span><br><span class="line">   </span><br><span class="line">create table t_student(</span><br><span class="line">id int primary key</span><br><span class="line">);</span><br><span class="line">create table t_course(</span><br><span class="line">id int primary key</span><br><span class="line">);</span><br><span class="line">create table t_sc(</span><br><span class="line">sid int,</span><br><span class="line">  cid int,</span><br><span class="line">  primary key(sid,cid),</span><br><span class="line">  foreign key(sid) references t_student(id),</span><br><span class="line">  foreign key(cid) references t_course(id)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="自学的知识点"><a href="#自学的知识点" class="headerlink" title="自学的知识点"></a>自学的知识点</h2><blockquote><p>四种分区方式 - 测试</p></blockquote><h1 id="DML操作"><a href="#DML操作" class="headerlink" title="DML操作"></a>DML操作</h1><h2 id="insert语句"><a href="#insert语句" class="headerlink" title="insert语句"></a>insert语句</h2><blockquote><ul><li><p>给表中所有的列都插入数据,但是需要注意的是顺序/类型/约束</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(列1,列2,列3);</span><br></pre></td></tr></tbody></table></figure></li><li><p>给指定的列插入数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(列名1,列名2) values(列1,列2);</span><br></pre></td></tr></tbody></table></figure></li><li><p>批量插入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(列1,列2,列3),(列1,列2,列3),(列1,列2,列3);</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h2 id="delete语句"><a href="#delete语句" class="headerlink" title="delete语句"></a>delete语句</h2><blockquote><ul><li><p>delete from 表名;//删除表中的数据</p></li><li><p>delete from 表名 where 条件;</p></li><li><p>外键约束会对delete产生影响,一定是先删除子记录,然后才能够删除父记录.</p><p>先删除多的一方,然后才能够删除一的一方.</p></li><li><p>级联删除 - 删除的一方之前先将这个一方的子记录全部删除</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">drop table t_ord;</span><br><span class="line">drop table t_customer;</span><br><span class="line">create table t_customer(</span><br><span class="line">id int(7),</span><br><span class="line">  cname varchar(20) not null,</span><br><span class="line">  constraint t_customer_id_pk primary key(id)</span><br><span class="line">);</span><br><span class="line">insert into t_customer values(1,'admin');</span><br><span class="line">insert into t_customer values(2,'tom');</span><br><span class="line"></span><br><span class="line">create table t_ord(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  ord_no varchar(20) not null unique,</span><br><span class="line">  total double(7,2),</span><br><span class="line">  customer_id int(7),</span><br><span class="line">  constraint t_ord_customer_id_fk foreign key(customer_id) references t_customer(id) on delete cascade</span><br><span class="line">);</span><br><span class="line">insert into t_ord values(1,'1001',300,1);</span><br><span class="line">insert into t_ord values(2,'1002',300,null);</span><br></pre></td></tr></tbody></table></figure><p>delete from t_customer where id=1;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h2 id="update语句"><a href="#update语句" class="headerlink" title="update语句"></a>update语句</h2><blockquote><ul><li>update 表 set 列名=列值,列名2=列值;//更新表中所有行</li><li>update 表 set 列名=列值,列名2=列值 WHERE条件;//</li></ul></blockquote><h2 id="truncate和delete和drop"><a href="#truncate和delete和drop" class="headerlink" title="truncate和delete和drop"></a>truncate和delete和drop</h2><p><code>共同点</code></p><blockquote><p>1.truncate和不带where子句的delete、以及drop都会删除表内的数据。</p><p>2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。</p></blockquote><p><code>不同点</code></p><blockquote><p> delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。</p><p> <strong>truncate</strong>、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，<strong>不能回滚</strong>，操作不触发 trigger</p></blockquote><blockquote><p>速度，一般来说: drop&gt; truncate &gt; delete</p></blockquote><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><blockquote><ul><li>limit m  // 前m行</li><li>limit m,n //   m从下标0开始(第一行),n显示行数</li></ul></blockquote><h2 id="分页的公式"><a href="#分页的公式" class="headerlink" title="分页的公式"></a>分页的公式</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">page</span><span class="params">(Integer pageNum,Integer pageSize)</span>{</span><br><span class="line">    <span class="comment">// limit (pageNum-1)*pageSize,pageSize</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1,3    0</span></span><br><span class="line">    <span class="comment">//2,2    3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分页的查询效率问题"><a href="#分页的查询效率问题" class="headerlink" title="分页的查询效率问题"></a>分页的查询效率问题</h2><blockquote><p>limit m,n 其中的m叫做偏移量. 偏移量越大,分页的性能越低.</p><p>比如表1-100000,正好id=1,10000</p><p>select * from 表 where id&gt;条件 limit 2;</p><p>条件查询(减少偏移量) + limit</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote><p>用来执行一组SQL,是db中完成<strong>业务的基本单位.</strong></p></blockquote><h2 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h2><blockquote><ol><li><p>原子性（Atomicity) - 事务不可再分割.</p><p>事务要么同时成功,同时失败 - 比如转账业务.</p></li><li><p>一致性(Consistency) - 事务一旦提交.内存中的数据要和磁盘上的数据要一致,保证数据的完整性.</p><p>比如tom-500,jack-500.无论转多少,转多少次.反正总的钱是1000</p></li><li><p>隔离性(isolation): 事务与事务之间的彼此隔离的,互不干扰的.一个事务的结束,意味着下一个事务的开始.</p></li><li><p>持久性(Durability) - 事务一旦提交,数据应该永久保存在磁盘中.即使发生一些故障,应该可以用一些恢复的技术进行恢复.</p></li></ol></blockquote><h2 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h2><blockquote><ol><li>本地事务 - 一个项目(单体架构)连接一个数据库</li><li>分布式事务 <ul><li>消息中间件 - rabbitmq,rocketmq</li><li>阿里的框架seata</li></ul></li></ol></blockquote><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><blockquote><ol><li><p>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p><p>锁表.</p></li><li><p>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p></li><li><p>③ Read committed (读已提交)：可避免脏读的发生。</p><p>一个事务只能读取到另外一个事务已经提交的数据.</p></li><li><p>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。产生脏读.</p><p>一个事务可以读取到另外一个事务尚未提交的数据</p></li></ol></blockquote><h2 id="查询当前会话的隔离级别"><a href="#查询当前会话的隔离级别" class="headerlink" title="查询当前会话的隔离级别"></a>查询当前会话的隔离级别</h2><p><code>mysql默认的是可重复读的隔离级别</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">临时设置一下当前会话的事务的隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></tbody></table></figure><h1 id="事务TCL命令"><a href="#事务TCL命令" class="headerlink" title="事务TCL命令"></a>事务TCL命令</h1><blockquote><p>begin(开启一个事务),commit(提交一个事务),savepoint 事务点</p><p>set autocommit=0;//手动开启一个事务</p><p>DML操作默认都是会自动提交事务.</p></blockquote><h2 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h2><blockquote><ol><li><p>rollback - 回滚事务 - 结束一个事务</p><p>不能回滚已经commit之后的事务.</p></li><li><p>savepoint 事务点</p><p>rollback to 事务点</p><p>如果么有设置事务点 - 回滚当前事务中所有的操作.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t_acc set balance=balance+1000 where id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint t1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t_acc set balance=balance+1000 where id=2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to t1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h1 id="多事务并发带来的问题"><a href="#多事务并发带来的问题" class="headerlink" title="多事务并发带来的问题"></a>多事务并发带来的问题</h1><blockquote><p>多个事务对同一个数据进行操作的时候,会产生一些问题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drop table t_acc;</span><br><span class="line">create table t_acc(</span><br><span class="line">id int,</span><br><span class="line">balance double(7,2)</span><br><span class="line">);</span><br><span class="line">insert into t_acc values(1,10000),(2,10000);</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><blockquote><p>一个事务读到了另外一个事务没有提交的数据 - 绝对不允许的.</p><p><img src="C:/Users/liming/Desktop/zang.png">  </p></blockquote><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><blockquote><p>set session transaction isolation level read committed;</p><p>一个事务A在读取一次之后,另外一个事务B在进行update操作.并且commit.</p><p>A事务在没有自己没有提交之前,读取到了B事务提交之后的数据.导致A事务在当前事务中多次读取到的结果不一样.</p><p><img src="C:/Users/liming/Desktop/no.png"> </p></blockquote><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><blockquote><p>它和不可重复读类似.侧重点不同.不可重复读强调的是一个事务在查询.另外一个事务在修改(update)</p><p>幻读强调的是一个事务在修改.另外一个事务在插入(insert).</p><p>set session transaction isolation level read committed;</p><p><img src="C:/Users/liming/Desktop/huan.png"> </p></blockquote><blockquote><p>事务A在修改,事务B-insert并且提交了.事务A在本事务中再次查询,发现了好像有”更新失败”的数据.就像发生了幻觉一样.</p></blockquote><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><blockquote><p>默认的隔离级别</p><p>set session transaction isolation level repeatable read;</p></blockquote><blockquote><p>事务A读取一次,事务B执行update操作.事务A在没有结束当前事务之前,多次读取到的结果是一样的.</p><p>必须要commit之后,才能够读取到B事务提交之后的修改数据.</p><p><img src="C:/Users/liming/Desktop/repeat.png"> </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DB设计&quot;&gt;&lt;a href=&quot;#DB设计&quot; class=&quot;headerlink&quot; title=&quot;DB设计&quot;&gt;&lt;/a&gt;DB设计&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;指导db设计的思想,避免表中出现大量的冗余的数据.但是实际开发中表中是允许出现冗余的字段的.&lt;/p</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="meet DB" scheme="https://apelisun.github.io/tags/meet-DB/"/>
    
  </entry>
  
  <entry>
    <title>mysql2</title>
    <link href="https://apelisun.github.io/2022/08/09/mysql2/"/>
    <id>https://apelisun.github.io/2022/08/09/mysql2/</id>
    <published>2022-08-09T13:22:58.000Z</published>
    <updated>2022-08-10T03:48:27.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图-view"></a>视图-view</h1><blockquote><p>我们使用create命令来构建database,user,<strong>table(基本单位)</strong>,view,索引,函数,存储过程,触发器 - 数据库的单位.</p><p>视图实际上就是一张”虚拟表”,实际上是不存在的.只是逻辑上的查询结果的集合.</p></blockquote><h2 id="视图的分类"><a href="#视图的分类" class="headerlink" title="视图的分类"></a>视图的分类</h2><blockquote><ol><li><p>简单视图</p><p>视图来自于单表查询的集合 - 允许执行DML操作</p></li><li><p>复杂视图</p><p>视图来自于多表关联查询的集合 - 不一定允许执行DML操作.</p></li></ol></blockquote><h2 id="创建的语法"><a href="#创建的语法" class="headerlink" title="创建的语法"></a>创建的语法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP view 视图名;</span><br><span class="line"></span><br><span class="line">CREATE VIEW 视图名</span><br><span class="line">AS</span><br><span class="line">SELECT查询语句;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view t_acc_view as select * from t_acc;</span><br><span class="line"></span><br><span class="line">select * from t_acc_view;</span><br></pre></td></tr></tbody></table></figure><p><code>复杂视图</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop view co_view;</span><br><span class="line">create view co_view as</span><br><span class="line">select c.cname,o.ord_no from t_customer c join t_ord o on c.id = o.customer_id;</span><br><span class="line"></span><br><span class="line">update co_view set cname='xx'; //允许update</span><br><span class="line"></span><br><span class="line">drop view co_view;</span><br><span class="line">create view co_view as</span><br><span class="line">select customer_id,count(*) c_ from t_ord group by customer_id;</span><br><span class="line"></span><br><span class="line">-- 不允许执行update操作.</span><br><span class="line">mysql&gt; update co_view set c_=1;</span><br><span class="line">ERROR 1288 (HY000): The target table co_view of the UPDATE is not updatable</span><br></pre></td></tr></tbody></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><ol><li><p>修改原表,视图肯定变化.有可能还会导致视图数据全部丢失.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">drop view t_acc_view;</span><br><span class="line">create view t_acc_view</span><br><span class="line">as</span><br><span class="line">select * from t_acc where balance=16000;</span><br><span class="line"></span><br><span class="line">-- 更新原表</span><br><span class="line"></span><br><span class="line">-- 更新了这个视图来源的那个条件列.</span><br><span class="line">update t_acc set balance = balance+1000 where id=2;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_acc_view;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改视图 - 同样也会对原表造成影响.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drop view t_acc_view;</span><br><span class="line">create view t_acc_view</span><br><span class="line">as</span><br><span class="line">select * from t_acc where id=1;</span><br><span class="line"></span><br><span class="line">-- 更新视图</span><br><span class="line">update t_acc_view set balance=1000 where id=1;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_acc;</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | balance  |</span><br><span class="line">+------+----------+</span><br><span class="line">|    1 |  1000.00 |</span><br><span class="line">|    2 | 17000.00 |</span><br><span class="line">|    3 | 15000.00 |</span><br><span class="line">+------+----------+</span><br></pre></td></tr></tbody></table></figure></li><li><p>针对题1的情况,更新列可能导致视图失效.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drop view t_acc_view;</span><br><span class="line">create view t_acc_view</span><br><span class="line">as</span><br><span class="line">SELECT带where的条件查询语句 with check option</span><br></pre></td></tr></tbody></table></figure><p><code>with check option作用:不允许更新视图的来源的那个条件列.  肯定是要配合where语句一起使用的,否则没有任何意义</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop view t_acc_view;</span><br><span class="line">create view t_acc_view</span><br><span class="line">as</span><br><span class="line">select * from t_acc where balance=1000 with check option;</span><br><span class="line"></span><br><span class="line">mysql&gt; update t_acc_view set balance=2000 where id=1;</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed 'dy.t_acc_view'</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h2><blockquote><ol><li><p>封装SQL语句</p><p>封装比较复杂的SQL语句,在Java中直接查询视图即可.</p></li><li><p>定制数据</p><p>系统不同的角色 - 看到的数据应该是不一样的.</p></li><li><p>安全性</p><p>数据库应该有多个user账号的,可以给不同的用户授予不同的视图的权限(select,insert,update,delete)</p><p>授权grant</p></li><li><p>合并抽离出去的数据 - 对用户屏蔽的底层的数据库的结构的设计.</p></li></ol></blockquote><h1 id="索引-index"><a href="#索引-index" class="headerlink" title="索引-index"></a>索引-index</h1><blockquote><p>作用:提高查询的效率,类似于书的那个目录.</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><ol><li><p>Myisam存储引擎</p><p>索引文件和数据文件是分开存储的.是俩个独立的文件</p><p>数据结构:B+树</p></li><li><p>Innodb存储引擎</p><p>数据和索引是合二为一的,是一个文件.</p><p>B+树</p></li></ol></blockquote><blockquote><ul><li>索引也是占用物理空间的.</li><li>对表中的数据进行DML操作的时候,维护索引的-消耗一点额外的时间</li><li>如果表中某列重复的数据比较多,没有必要创建索引 - 查找的时候接近于全表扫描花费的时间.</li><li>当表中没有指定索引列,那么默认的索引列就是主键列.</li><li>show index from 表名 \G;</li></ul></blockquote><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><blockquote><ul><li><p>主键索引</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Key_name: PRIMARY</span><br><span class="line"></span><br><span class="line">-- 非要删除主键约束</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></tbody></table></figure></li><li><p>唯一索引</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某列增加unique唯一约束,自动创建唯一索引</span><br></pre></td></tr></tbody></table></figure></li><li><p>全文索引</p><p>后期会使用elasticsearch来进行全文搜索 - 搜索引擎.</p></li><li><p>复合索引 - 遵守最左匹配原则.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on 表名(列1,列2,列3);</span><br></pre></td></tr></tbody></table></figure></li><li><p>普通索引</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on 表名(列);</span><br><span class="line">drop index index_name;</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h1 id="索引失效场景※"><a href="#索引失效场景※" class="headerlink" title="索引失效场景※"></a>索引失效场景※</h1><blockquote><p>如何查看索引是否生效 - 索引执行计划explain select语句;</p><p>type - <em>const</em>&gt;eq_<em>ref</em>&gt;<em>ref</em>&gt;range&gt;index&gt;<em>all</em>)</p><p>type-all 全表扫描 - 索引是失效的.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain select * from index_test where id=1;</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | index_test | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table index_test;</span><br><span class="line">create table index_test(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  a int(7),</span><br><span class="line">  b int(7),</span><br><span class="line">  c varchar(20),</span><br><span class="line">  d varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into index_test values(1,100,10,'aaa','AAA');</span><br><span class="line">insert into index_test values(2,200,30,'aab','BBB');</span><br><span class="line">insert into index_test values(3,300,20,'caa','CCC');</span><br><span class="line">insert into index_test values(4,100,10,'daa','DDD');</span><br><span class="line">insert into index_test values(5,500,50,'aad','FFF');</span><br><span class="line"></span><br><span class="line">drop index index_test_index;</span><br><span class="line">create index index_test_index on index_test(a,b,c);</span><br><span class="line"></span><br><span class="line">create index index_test_d on index_test(d(10));//10 - 索引长度</span><br></pre></td></tr></tbody></table></figure><h2 id="1-复合索引需要遵守最左匹配原则"><a href="#1-复合索引需要遵守最左匹配原则" class="headerlink" title="1. 复合索引需要遵守最左匹配原则"></a>1. 复合索引需要遵守最左匹配原则</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- a,b,c都是走了索引的.</span><br><span class="line">explain select * from index_test where a = 2 and b=200 and c='aaa';</span><br><span class="line"></span><br><span class="line">type:ref   key_len: 73</span><br><span class="line"></span><br><span class="line">-- a走了索引</span><br><span class="line">explain select * from index_test where a = 2;</span><br><span class="line">type: ref  key_len:5</span><br><span class="line"></span><br><span class="line">-- a,b都是走了索引</span><br><span class="line">explain select * from index_test where a = 2 and b=200;</span><br><span class="line">type:ref key_len:10</span><br><span class="line"></span><br><span class="line">-- b是不走的</span><br><span class="line">explain select * from index_test where b=200;</span><br><span class="line">type:ALL key_len:NULL</span><br><span class="line"></span><br><span class="line">-- type:ref   key_len: 73</span><br><span class="line">-- mysql底层发现where条件列a,b,c都是复合索引,先进行优化,a,b,c,进行查询.</span><br><span class="line">explain select * from index_test where b=200 and c='aaa' and a=2;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-模糊匹配"><a href="#2-模糊匹配" class="headerlink" title="2. 模糊匹配"></a>2. 模糊匹配</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- %在末尾 - 生效</span><br><span class="line">explain select * from index_test where a = 2 and b=200 and c like 'a%';</span><br><span class="line"></span><br><span class="line">-- %在开头,a,b是走索引,但是c没有走索引</span><br><span class="line">explain select * from index_test where a = 2 and b=200 and c like '%a';</span><br><span class="line"></span><br><span class="line">-- %?%,a,b是走索引,但是c没有走索引</span><br><span class="line">explain select * from index_test where a = 2 and b=200 and c like '%a%';</span><br></pre></td></tr></tbody></table></figure><h2 id="3-查询范围之后"><a href="#3-查询范围之后" class="headerlink" title="3. 查询范围之后"></a>3. 查询范围之后</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- b&gt;=10 条件成立,范围之后的索引是生效的.  a,b,c都是走索引</span><br><span class="line">explain select * from index_test where a = 100 and b&gt;=10 and c='aaa';</span><br><span class="line"></span><br><span class="line">-- b&gt;10 条件不成立,范围之后的索引是失效的.  只有a,b是走索引的</span><br><span class="line">explain select * from index_test where a = 100 and b&gt;10 and c='aaa';</span><br></pre></td></tr></tbody></table></figure><h2 id="4-索引列参加了计算"><a href="#4-索引列参加了计算" class="headerlink" title="4. 索引列参加了计算"></a>4. 索引列参加了计算</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- type:ALL</span><br><span class="line">explain select * from index_test where id+1=1;</span><br></pre></td></tr></tbody></table></figure><h2 id="5-索引列使用了函数"><a href="#5-索引列使用了函数" class="headerlink" title="5. 索引列使用了函数"></a>5. 索引列使用了函数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- type:ALL</span><br><span class="line">explain select * from index_test where abs(id)=1;</span><br></pre></td></tr></tbody></table></figure><h2 id="6-查询的数据超过整张表的30"><a href="#6-查询的数据超过整张表的30" class="headerlink" title="6. 查询的数据超过整张表的30%"></a>6. 查询的数据超过整张表的30%</h2><h2 id="7-is-null和is-not-null"><a href="#7-is-null和is-not-null" class="headerlink" title="7. is null和is not null"></a>7. is null和is not null</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create index emp_index on s_emp(commission_pct);</span><br><span class="line"></span><br><span class="line">-- typ:ALL is null 没有走索引</span><br><span class="line">explain select * from s_emp where commission_pct is null;</span><br><span class="line"></span><br><span class="line">-- type:range is not 走索引.</span><br><span class="line">explain select * from s_emp where commission_pct is not null;</span><br></pre></td></tr></tbody></table></figure><h2 id="8-in和not-in"><a href="#8-in和not-in" class="headerlink" title="8. in和not in"></a>8. in和not in</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain select * from s_emp where id in(1,2,3);</span><br><span class="line">explain select * from s_emp where id not in(1,2,3);</span><br><span class="line"></span><br><span class="line">-- mysql5.7之前</span><br><span class="line">in - 走索引</span><br><span class="line">not in - 不走索引</span><br><span class="line"></span><br><span class="line">-- 8.x not in允许走索引</span><br></pre></td></tr></tbody></table></figure><h1 id="关于索引的长度key-len"><a href="#关于索引的长度key-len" class="headerlink" title="关于索引的长度key_len"></a>关于索引的长度key_len</h1><h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h2><blockquote><ol><li><p>数值类型 - int</p><p>4 + 1(该列是否为null,没有设置not null,就需要加1,存储null也占1个)</p></li><li><p>字符串类型 - varchar(n) - utf8 - n*3+2+1(没有设置not null,就需要加1,存储null也占1个)</p></li></ol></blockquote><h2 id="索引长度作用"><a href="#索引长度作用" class="headerlink" title="索引长度作用"></a>索引长度作用</h2><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">site: www.baidu.com</span><br><span class="line">   www.baobao.com</span><br><span class="line">   www.baxy.com</span><br><span class="line">   </span><br><span class="line">site索引长度是5,不够,前缀重复比较多.</span><br><span class="line">索引长度要有区分度.</span><br><span class="line"></span><br><span class="line">推荐反转之后进行存储.减少索引长度.</span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="索引的创建策略"><a href="#索引的创建策略" class="headerlink" title="索引的创建策略"></a>索引的创建策略</h1><blockquote><ul><li><p>哪些列创建索引</p><ul><li><p>主键列,唯一性列</p></li><li><p>重复性比较少,经常被查询但是同时更新不是特别频繁的列.</p></li><li><p>order by + 排序列 - 创建索引.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">order by语句本身性能就很低下的.  根据索引进行排序.</span><br><span class="line">如果是id列索引,插入的时候就会先排序了.</span><br></pre></td></tr></tbody></table></figure></li><li><p>join on 列</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来连接表的列适合建索引的.本身join越多,性能越低.</span><br><span class="line">开发中几乎都是单表查询.尽量不要去使用复杂查询.</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>不适合创建索引</p><ul><li>null值太多的列</li><li>重复值太多的列</li><li>更新比较频繁的列</li></ul></li></ul></blockquote><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><blockquote><ol><li><p>行锁</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update s_emp set first_name='xxx' where id=1;//条件列是索引列 - 行锁 - 降低锁的粒度</span><br><span class="line"></span><br><span class="line">行锁和表锁</span><br><span class="line">1. 行锁粒度小,涉及到频繁的加锁和释放锁的过程.</span><br><span class="line">3. 表锁会影响到查询效率</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update s_emp set first_name='xxx' where id=1;//如果上面的事务没有commit,此处会阻塞</span><br><span class="line"></span><br><span class="line">如果此处更新的是另外一行,可以直接执行update s_emp set first_name='xxx' where id=2;</span><br></pre></td></tr></tbody></table></figure></li><li><p>表锁</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非索引列条件更新的时候 - 锁表.</span><br><span class="line">所有的DML操作默认的申请表锁</span><br></pre></td></tr></tbody></table></figure></li><li><p>页锁</p><p>介于行锁和表锁之间的.</p></li><li><p>共享锁</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select语句默认申请的共享锁.</span><br><span class="line">select申请排他锁.</span><br><span class="line"></span><br><span class="line">select语句 for update;</span><br><span class="line"></span><br><span class="line">实现悲观锁</span><br><span class="line"></span><br><span class="line">更新库存stock</span><br><span class="line"></span><br><span class="line">伪代码:</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line"></span><br><span class="line">select stock from xxx where id=1 for update;</span><br><span class="line"></span><br><span class="line">//更新stock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视图-view&quot;&gt;&lt;a href=&quot;#视图-view&quot; class=&quot;headerlink&quot; title=&quot;视图-view&quot;&gt;&lt;/a&gt;视图-view&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们使用create命令来构建database,user,&lt;strong&gt;</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="view" scheme="https://apelisun.github.io/tags/view/"/>
    
  </entry>
  
  <entry>
    <title>mysql1</title>
    <link href="https://apelisun.github.io/2022/08/09/mysql1/"/>
    <id>https://apelisun.github.io/2022/08/09/mysql1/</id>
    <published>2022-08-09T13:22:47.000Z</published>
    <updated>2022-08-10T09:29:10.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h1><blockquote><p>按照一定的数据结构来组织,管理和存储数据的仓库</p><p>用仓库的方式来管理数据的.一个仓库下会有很多表.一个表由行和列构成.</p></blockquote><h2 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h2><blockquote><ol><li><p>关系型数据库 </p><p><code>表格型数据库 - 有行和列来构成一张表,表中存放数据</code></p><p>常见的产品:MS-sqlserver,主流的免费的Oracle-mysql(中小型的应用),收费的Oracle-oracle(大型的应用)</p></li><li><p>nosql - 不仅仅是sql - 非关系型数据库</p><ul><li>键值对数据库 - redis</li><li>文档型数据库 - mongodb</li><li>列式数据库 - hbase</li><li>图形数据库</li></ul></li></ol></blockquote><h2 id="数据库安装注意点"><a href="#数据库安装注意点" class="headerlink" title="数据库安装注意点"></a>数据库安装注意点</h2><blockquote><ol><li><p>server和client</p><p>当我们安装好db之后,自带安装好了mysql-server端和mysql-client端</p><p><code>db正常使用,一定要保障mysql-server端处于运行状态</code></p><ul><li><p>右击计算机 - 管理 - 服务 - 服务和应用程序 - 👉🏻右边窗口 - Mysql - 启动方式设置开启自启.</p></li><li><p>可以通过终端输入命令来启动mysql-server端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol></blockquote><blockquote><ol start="2"><li>mysql-client客户端<ul><li>第三方的收费navicat</li><li>idea</li><li>java代码</li><li>自带的控制台</li></ul></li></ol></blockquote><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><blockquote><ol><li><p>DB - DataBase 数据库</p></li><li><p>DBA - 数据库管理员(侧重于运维),DE - 数据库研发工程师</p></li><li><p>DBMS - 数据库管理系统,安装在操作系统.用户通过dbms来操作db,dba通过dbms来管理db,保证db在7*24h高效运转</p><p><code>人 - dbms - db(os)</code></p></li><li><p>RDBMS - 关系型数据库管理系统 </p></li><li><p>DBS - 数据库系统,大的范畴,dbs = dba+db+dbms</p></li></ol></blockquote><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><blockquote><p><code>前提:mysql安装并且配置好了环境变量</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></tbody></table></figure><p><code>修改密码</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alter user '用户名'@'db所在主机ip' identified by '新的密码';</span><br><span class="line"></span><br><span class="line">use mysql</span><br><span class="line"></span><br><span class="line">alter user 'root'@'localhost' identified by 'root';</span><br><span class="line"></span><br><span class="line">-- 退出重新登录</span><br><span class="line">exit;</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="导入脚本"><a href="#导入脚本" class="headerlink" title="导入脚本"></a>导入脚本</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 创建数据库  create dabatase 数据库名</span><br><span class="line">create database dy;</span><br><span class="line"></span><br><span class="line">-- 查看所有的db</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 2. 使用数据库</span><br><span class="line">use dy</span><br><span class="line"></span><br><span class="line">-- 3. 导入脚本 - .sql为后缀的sql文件</span><br><span class="line">-- 3-1. 在dy数据库中生成5张表</span><br><span class="line">-- 3-2. 每张表中模拟一些数据</span><br><span class="line">source 脚本文件的绝对路径;</span><br><span class="line"></span><br><span class="line">-- 4. 查看该库下所有的表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| Tables_in_dy |</span><br><span class="line">+--------------+</span><br><span class="line">| s_customer   |</span><br><span class="line">| s_dept       |</span><br><span class="line">| s_emp        |</span><br><span class="line">| s_ord        |</span><br><span class="line">| s_region     |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line">--5. 查看表结构</span><br><span class="line">desc s_emp</span><br></pre></td></tr></tbody></table></figure><h2 id="设置数据库编码"><a href="#设置数据库编码" class="headerlink" title="设置数据库编码"></a>设置数据库编码</h2><blockquote><ol><li><p>查看编码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'character_set%';</span><br><span class="line"></span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                     |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                      |</span><br><span class="line">| character_set_connection | utf8                                                      |</span><br><span class="line">| character_set_database   | utf8                                                      |</span><br><span class="line">| character_set_filesystem | binary                                                    |</span><br><span class="line">| character_set_results    | utf8                                                      |</span><br><span class="line">| character_set_server     | utf8                                                      |</span><br><span class="line">| character_set_system     | utf8                                                      |</span><br><span class="line">| character_sets_dir       | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+-----------------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改编码</p><p>2-1. 临时修改 - set命令 - 仅仅是对当前会话(一次连接,窗口)有效</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set names utf8;</span><br></pre></td></tr></tbody></table></figure><p>2-2. 永久生效 - 找到<strong>my.ini文件</strong></p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character_set_server</span>=utf8</span><br></pre></td></tr></tbody></table></figure><p>需要重启mysql-server(mysql服务器端),才能生效.</p><ol><li><p>通过gui方式</p></li><li><p>通过命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol></blockquote><h2 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h2><blockquote><p>SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。</p><p>①mysql-client输入合法的sql语句,如果sql非法,直接报错</p><p>②输入回车- 客户端将sql语句发送到mysql-server端,编译和解析sql语句的.</p><p>③mysql-server将执行完sql语句的结果返回到mysql-client进行展示.</p></blockquote><h3 id="按照功能SQL分类"><a href="#按照功能SQL分类" class="headerlink" title="按照功能SQL分类"></a>按照功能SQL分类</h3><blockquote><ol><li><p>DDL(Data Definition Language) - 数据定义语言</p><p>create drop alter truncate rename comment(注释)</p></li><li><p>DML(Data Manipulation Language) - 数据操纵语言</p><p>update delete insert</p></li><li><p>DQL(Data Query Language) - 数据查询语言</p><p>select</p></li><li><p>TCL/DTL(Transaction Control Language):事务控制语言</p><p>commit savepoint rollback</p></li></ol></blockquote><h1 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h1><blockquote><ol><li><p>查询的本质</p><ul><li>到哪里查</li><li>查什么</li></ul></li><li><p>语法 - 关键字是大小写不敏感</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,..列n</span><br><span class="line"><span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="列取别名"><a href="#列取别名" class="headerlink" title="列取别名"></a>列取别名</h2><blockquote><ol><li><p>查询员工的名字,薪水以及职称.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary,title from s_emp;</span><br></pre></td></tr></tbody></table></figure><p><code>方式一</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1 列别名,列名2 列别名,..列n</span><br><span class="line">FROM 表名;</span><br><span class="line"></span><br><span class="line">select first_name 名字,salary 薪水,title 职称 from s_emp;</span><br></pre></td></tr></tbody></table></figure><p><code>方式二</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1 as 列别名,列名2 as 列别名,..列n</span><br><span class="line">FROM 表名;</span><br><span class="line"></span><br><span class="line">select first_name as 名字,salary as 薪水,title as 职称 from s_emp;</span><br></pre></td></tr></tbody></table></figure><p><code>方式三</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">列别名中间有空格,需要使用双引号来包裹格式</span><br><span class="line">select first_name "名 字",salary "薪 水",title as "职 称" from s_emp;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询所有列*</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 格式化输出</span><br><span class="line">select * from s_emp;</span><br><span class="line">   </span><br><span class="line">select * from s_emp \G;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="去重关键字"><a href="#去重关键字" class="headerlink" title="去重关键字"></a>去重关键字</h2><blockquote><p>distinct</p><ol><li><p>查询员工表中所有的职称的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct title from s_emp;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="列的计算"><a href="#列的计算" class="headerlink" title="列的计算"></a>列的计算</h2><blockquote><p>列是允许计算的</p><ol><li><p>查询员工的名字,年薪(不带提成commission_pct)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*12 年薪 from s_emp;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询员工的名字,年薪(带提成commission_pct)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+commission_pct/100)*12 年薪 from s_emp;</span><br><span class="line">   </span><br><span class="line">查询出来只有5个人有年薪,原因是因为只有5个人有提成.其他人的提成都是null值</span><br><span class="line">mysql - null值计算的结果还是一个null值</span><br><span class="line">   </span><br><span class="line">使用到mysql中提供的空值置换函数</span><br><span class="line">coalesce(m,n) - 如果m为null,返回n,否则返回m</span><br><span class="line">   </span><br><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>找出员工的姓名,工资以及入职日期</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select last_name,first_name,salary,start_date from s_emp;</span><br><span class="line"></span><br><span class="line">-- 列的拼接 concat(m,n,a,b,c,..)</span><br><span class="line">-- mysql中的字符串统一使用单引号</span><br><span class="line">select concat(last_name,'  ',first_name) 姓名,salary,start_date from s_emp;</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出所有的客户名以及他的联系方式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name,phone from s_customer;</span><br><span class="line"></span><br><span class="line">-- 查询姓名的时候</span><br><span class="line">-- 蔡根花 - 蔡**</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出每个订单的费用,支付方式以及出货日期</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select total,payment_type,date_ordered from s_ord;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1,列名2,..列n</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></tbody></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>比较运算符</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt; &gt;= &lt;= != &lt;&gt; =</span><br></pre></td></tr></tbody></table></figure><p><code>其他运算符</code></p><blockquote><ol><li>between …  and ..  在…到…之间</li><li>in(集合) - 在某个集合内</li><li>not in(集合) - 不在某个集合内</li><li>is - 判断是否为null,判断null值不能用=</li><li>is not - 判断是否不为null</li></ol></blockquote><p><code>逻辑连接符</code></p><blockquote><ol><li>and 条件同时成立,返回true</li><li>or 有一个条件成立,就返回true</li></ol></blockquote><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>查询部门编号(dept_id)为41,42,45的员工找出来</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select first_name,dept_id from s_emp</span><br><span class="line">where dept_id=41 or dept_id=42 or dept_id=45;</span><br><span class="line"></span><br><span class="line">select first_name,dept_id from s_emp where dept_id in(41,42,45);</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询没有提成的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,commission_pct from s_emp where commission_pct is null;</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出工资在[1200,1500]之间的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary from s_emp where salary between 1200 and 1500;</span><br><span class="line"></span><br><span class="line">-- 更加灵活</span><br><span class="line">select first_name,salary from s_emp where salary&gt;=1200 and salary&lt;=1500;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查找工资大于1500并且没有提成的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary from s_emp where salary&gt;1500 and commission_pct is null;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查找年薪(包括提成)超过15000的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 _year from s_emp</span><br><span class="line">where salary*(1+coalesce(commission_pct,0)/100)*12&gt;15000;</span><br><span class="line"></span><br><span class="line">-- 给列取别名的意义</span><br><span class="line">-- 子查询 - 查询的结果作为虚拟表 - 子查询一定要放在()中</span><br><span class="line">select * from X where _year&gt;15000;</span><br><span class="line"></span><br><span class="line">查询的结果来替代X,子查询的结果作为表的话 - 需要给表取别名</span><br><span class="line">select * from (select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 _year from s_emp) core_ where _year&gt;15000;</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出除了41部门的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select first_name,dept_id from s_emp where dept_id &lt;&gt; 41;</span><br><span class="line"></span><br><span class="line">select first_name,dept_id from s_emp where dept_id not in(41);</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出亚洲区域的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- mysql中采用单引号</span><br><span class="line">select * from s_region where name='Asia';</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><blockquote><p>大小写不敏感的</p></blockquote><blockquote><ol><li>关键字like</li><li>占位符<ul><li>% 代表的任意多个任意字符</li><li>_ 代表的是任意单个字符</li></ul></li></ol></blockquote><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><blockquote><ul><li><p>first_name名称正好包含了%或者_</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update s_emp set first_name='Mar%k' where id=4;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询first_name包含%的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 定义转义字符,默认的是\</span><br><span class="line">select first_name from s_emp where first_name like '%\%%';</span><br><span class="line">  </span><br><span class="line">-- 自定义转义字符,用escape 新的转义字符</span><br><span class="line">select first_name from s_emp where first_name like '%?%%' escape '?';</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>查询first_name包含m的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from s_emp where first_name like '%m%';</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询以C开头的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from s_emp where first_name like 'C%';</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询第三个字母是’e’的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name from s_emp where first_name like '__e%';</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询入职时间是6月份的员工 - 模糊查询 - 不是正规的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,start_date from s_emp where start_date like '%-06-%';</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1,列名2,..列n</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件表达式</span><br><span class="line">ORDER By语句 [asc|desc]</span><br><span class="line"></span><br><span class="line">asc可以省略不写 - 升序</span><br><span class="line">desc必须要写 - 降序</span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><p>根据年薪降序排列</p><p><code>方式一: order by 列名</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 from s_emp </span><br><span class="line">order by salary*(1+coalesce(commission_pct,0)/100)*12 desc;</span><br></pre></td></tr></tbody></table></figure><p><code>方式二:</code> order by 列别名</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp </span><br><span class="line">order by 年薪 desc;</span><br></pre></td></tr></tbody></table></figure><p><code>方式三: order by 列的序号</code>  列的序号从1开始 =&gt; 推荐方式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp </span><br><span class="line">order by 2 desc;</span><br></pre></td></tr></tbody></table></figure></li><li><p>根据年薪降序排.如果年薪一样,则继续按照first_name升序排列</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp </span><br><span class="line">order by 2 desc,1;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><h3 id="数字和字符串"><a href="#数字和字符串" class="headerlink" title="数字和字符串"></a>数字和字符串</h3><blockquote><ol><li><p>字符串转换成数字</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select '1'+0;</span><br><span class="line"></span><br><span class="line">mysql中字符数字遇到数字进行+,自动将字符转换成数字来进行计算.</span><br></pre></td></tr></tbody></table></figure></li><li><p>数字转换成字符串 - concat函数 - 拼接删除</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(1,2);  // 12</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h3 id="字符串和日期"><a href="#字符串和日期" class="headerlink" title="字符串和日期"></a>字符串和日期</h3><blockquote><p>关于日期模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(在format字符串中可用标志符:  </span><br><span class="line">　%m 月名字(january……december)    </span><br><span class="line">　%w 星期名字(sunday……saturday)    </span><br><span class="line">　%d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）    </span><br><span class="line">　%Y 年, 数字, 4 位    </span><br><span class="line">　%y 年, 数字, 2 位    </span><br><span class="line">　%a 缩写的星期名字(sun……sat)    </span><br><span class="line">　%d 月份中的天数, 数字(00……31)    </span><br><span class="line">　%e 月份中的天数, 数字(0……31)    </span><br><span class="line">　%m 月, 数字(01……12)    </span><br><span class="line">　%c 月, 数字(1……12)    </span><br><span class="line">　%b 缩写的月份名字(jan……dec)    </span><br><span class="line">　%j 一年中的天数(001……366)    </span><br><span class="line">　%H 24时制小时(00……23)    </span><br><span class="line">　%k 小时(0……23)    </span><br><span class="line">　%h 12时小时(01……12)    </span><br><span class="line">　%i 小时(01……12)    </span><br><span class="line">　%l 小时(1……12)    </span><br><span class="line">　%i 分钟, 数字(00……59)    </span><br><span class="line">　%r 时间,12 小时(hh:mm:ss [ap]m)    </span><br><span class="line">　%t 时间,24 小时(hh:mm:ss)    </span><br><span class="line">　%s 秒(00……59)       </span><br><span class="line">　%p am或pm    </span><br><span class="line">　%w 一个星期中的天数(0=sunday ……6=saturday ）  </span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><ol><li><p>获取当前系统的日期</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select now();</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| now()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2022-08-05 11:09:49 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></tbody></table></figure></li><li><p>日期转换成指定格式的字符串 - date_format(日期,模板)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模板  %Y   %m    %d  %H  %i   %s</span><br><span class="line"></span><br><span class="line">select date_format(now(),'%Y/%m/%d %H:%i:%s');</span><br><span class="line"></span><br><span class="line">select date_format(now(),'%Y年%m月%d日 %H时%i分%s秒');</span><br></pre></td></tr></tbody></table></figure></li><li><p>字符串转成日期 - str_to_date(字符串,模板) - 字符串格式要和模板的格式匹配</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表</span><br><span class="line">drop table tt;</span><br><span class="line">-- 创建表</span><br><span class="line">create table tt(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  birthday date</span><br><span class="line">);</span><br><span class="line">   </span><br><span class="line">-- date - 年月日</span><br><span class="line">-- 插入数据</span><br><span class="line">-- mysql中默认支持的格式 - 会将字符串自动转成date类型</span><br><span class="line">insert into tt values(1,'admin','2022-09-01');//ok</span><br><span class="line">insert into tt values(2,'tom','2022/09/01');//ok</span><br><span class="line">insert into tt values(3,'jack','20221001');//ok</span><br><span class="line">   </span><br><span class="line">-- 不支持的时候</span><br><span class="line">insert into tt values(4,'jack','aa');</span><br><span class="line">ERROR 1292 (22007): Incorrect date value: 'aa' for column 'birthday' at row 1</span><br><span class="line">   </span><br><span class="line">insert into tt values(4,'jack','01-05-2022');</span><br><span class="line">ERROR 1292 (22007): Incorrect date value: '01-05-2022' for column 'birthday' at row 1</span><br><span class="line">   </span><br><span class="line">-- 非要使用'01-05-2022'字符串格式的,才需要使用str_to_date函数进行转换</span><br><span class="line">insert into tt values(4,'jack',str_to_date('01-05-2022','%d-%m-%Y'));</span><br></pre></td></tr></tbody></table></figure><p><code>导入脚本的时候 - 失败场景 - 字符串日期格式不支持</code></p></li></ol></blockquote><h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><blockquote><ul><li><p>select 函数(参数);</p></li><li><p>函数是可以应用在查询列上的.</p></li><li><p>函数是允许嵌套使用的.</p></li></ul></blockquote><h2 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h2><blockquote><ol><li><p>instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0)</p></li><li><p>lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lpad('ab',5,'cd');//cdcab</span><br></pre></td></tr></tbody></table></figure></li><li><p>rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select rpad('ab',5,'cd');//abcdc   5代表的是总的长度</span><br></pre></td></tr></tbody></table></figure></li><li><p>left(str,len) - 返回字符串str的左端len个字符 </p></li><li><p>right(str,len) - 返回字符串str的右端len个字符 </p></li><li><p>substring(str,pos,len) - 返回字符串str的位置pos起len个字符  </p></li><li><p>substring(str,pos) - 返回字符串str的位置pos起后面的子串 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序号从1开始</span><br><span class="line">select substring('mysql',2);  //ysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>ltrim(str) - 返回删除了左空格的字符串str  </p></li><li><p>rtrim(str)  - 返回删除了右空格的字符串str  </p></li><li><p>space(n) - 返回由n个空格字符组成的一个字符串  </p></li><li><p><em><strong>replace(str,from_str,to_str)  - 用字符串to_str替换字符串str中的子串from_str并返回</strong></em></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select replace('i love java','java','mysql');</span><br></pre></td></tr></tbody></table></figure></li><li><p>reverse(str) - 颠倒字符串str的字符顺序并返回</p></li><li><p>insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select insert('xxxxx',1,2,'**');</span><br></pre></td></tr></tbody></table></figure></li><li><p>lower(str) - 返回小写的字符串str  </p></li><li><p>upper(str) - 返回大写的字符串str</p></li><li><p>char_length(str) -  不管汉字还是数字或者是字母都算是一个字符。</p></li><li><p>length(str);//汉字占3个,其他占1个.</p></li></ol></blockquote><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>配合表 - 将first_name全部转换成大写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select first_name,upper(first_name) from s_emp;</span><br></pre></td></tr></tbody></table></figure></li><li><p>first_name  - 模拟银行账户显示,只显示首字母,其余每个字母用*表示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- substring和rpad</span><br><span class="line">select first_name,rpad(substring(first_name,1,1),char_length(first_name),'*') from s_emp;</span><br><span class="line"></span><br><span class="line">-- concat + substring + rpad</span><br><span class="line">select first_name,concat(substring(first_name,1,1),rpad('*',char_length(first_name)-1,'*')) from s_emp;</span><br><span class="line"></span><br><span class="line">-- replace + substring + rpad</span><br><span class="line">select first_name,replace(first_name,substring(first_name,2),rpad('*',char_length(first_name)-1,'*'))</span><br><span class="line">from s_emp;</span><br><span class="line"></span><br><span class="line">-- insert + rpad</span><br><span class="line">select first_name,insert(first_name,2,char_length(first_name)-1,rpad('*',char_length(first_name)-1,'*'))</span><br><span class="line">from s_emp;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="2-数字函数"><a href="#2-数字函数" class="headerlink" title="2. 数字函数"></a>2. 数字函数</h2><blockquote><ol><li>abs(n) - 求绝对值</li><li>mod(n,m) - 取模运算,返回n被m除的余数(同%操作符)</li><li><strong>floor(n) - 返回不大于n的最大整数值</strong> - 向下取整  </li><li><strong>ceiling(n) - 返回不小于n的最小整数值</strong>  - 向上取整 </li><li>round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0)</li><li>pow(x,y) - 返回值x的y次幂  </li><li>sqrt(n) - 返回非负数n的平方根</li><li>pi() - 返回圆周率  </li><li>rand() - 返回在范围[0到1.0)内的随机浮点值</li><li>truncate(n,d) - 保留数字n的d位小数并返回  - 直接截取</li></ol></blockquote><h2 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h2><blockquote><p>查询当前系统的日期 - select now();</p><ol><li><p>dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准)  </p></li><li><p>weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天)</p></li><li><p>year(date) - 返回date的年份(范围在1000到9999)    </p></li><li><p>month(date)  - 返回date中的月份数值   </p></li><li><p>dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内)   </p></li><li><p>hour(time) - 返回time的小时数(范围是0到23)  </p></li><li><p>minute(time) - 返回time的分钟数(范围是0到59) </p></li><li><p>second(time) - 返回time的秒数(范围是0到59) </p></li><li><p>period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) </p><p>mysql&gt;select period_add(‘202008’,3) ;</p><p>注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型.</p></li><li><p>period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm)  p1-p2</p></li><li><p>curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) </p></li><li><p>curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字)</p></li><li><p>now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字)     </p></li><li><p>last_day(date) - date日期所在月的最后一天是什么时候</p></li><li><p>datediff(d1,d2) - 两个日期d1,d2之间相差的天数</p></li><li><p>timestampdiff(type,d1,d2) - type是YEAR,d1和d2相差的年份,MONTH,月份</p><p>d1,d2 - yyyymmdd</p></li></ol></blockquote><h3 id="3-1-补充"><a href="#3-1-补充" class="headerlink" title="3-1. 补充"></a>3-1. 补充</h3><blockquote><ul><li><p>date_add(date,interval expr type)</p></li><li><p>date_sub(date,interval expr type)</p></li><li><p>关于type</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ype:</span><br><span class="line">year</span><br><span class="line">month</span><br><span class="line">day</span><br><span class="line">hour</span><br><span class="line">minute</span><br><span class="line">second</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><p>#关联查询 </p><blockquote><p>关联查询就是多表查询</p></blockquote><h2 id="错误的写法"><a href="#错误的写法" class="headerlink" title="错误的写法"></a>错误的写法</h2><blockquote><p>s_emp表中25rows,s_dept表中12rows</p><ol><li><p>查询员工的名字以及这个员工的部门名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select first_name,name from s_emp,s_dept;</span><br><span class="line"></span><br><span class="line">300 rows </span><br><span class="line"></span><br><span class="line">发生了笛卡尔积 - 错误的结果</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h3 id="纠正-传统的写法"><a href="#纠正-传统的写法" class="headerlink" title="纠正 - 传统的写法"></a>纠正 - 传统的写法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">select first_name,name from s_emp,s_dept where dept_id=id;</span><br><span class="line"></span><br><span class="line">ERROR 1052 (23000): Column 'id' in where clause is ambiguous</span><br><span class="line"></span><br><span class="line">多张表中出现同名的列,需要对表取别名</span><br><span class="line"></span><br><span class="line">正确的写法:</span><br><span class="line">select e.first_name,d.name from s_emp e,s_dept d where e.dept_id=d.id;</span><br><span class="line"></span><br><span class="line">-- 用来表示表与表之间的关系foreign key - 外键</span><br><span class="line"></span><br><span class="line">-- 查询这个员工的first_name以及这个员工所在的区域名.</span><br><span class="line">-- 一个区域对应多个部门,一个部门对应多个员工.</span><br><span class="line">select e.first_name,r.name from s_emp e,s_dept d,s_region r</span><br><span class="line">where d.region_id = r.id and e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">for( ...  s_emp e){</span><br><span class="line">for(... s_dept d){</span><br><span class="line">    if(e.dept_id==d.id){</span><br><span class="line">      e+":"+d</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="join和on写法"><a href="#join和on写法" class="headerlink" title="join和on写法"></a>join和on写法</h2><blockquote><p>如果一条sql语句涉及到的表比较多的话,传统的写法,就不能很直观的看出来哪个表和哪个表之间有直接的关系.</p><p>表 join 表 on 去除笛卡尔积</p><p>外键一定是出现在多的一方</p><p><em><strong>on 多的一方的外键 = 一的一方主键</strong></em></p><p><code>但是也不一定非要使用外键来去除笛卡尔积</code></p></blockquote><blockquote><p>规则: 能够用join连接的表之间必须要有直接的关系.</p></blockquote><h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><blockquote><ol><li><p>找出查询员工的名字以及这个员工的部门名称</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.first_name,d.name from s_emp e join s_dept d on e.dept_id = d.id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出’Asia’区域上的所有的员工</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select e.first_name,r.name from </span><br><span class="line">s_emp e join s_dept d</span><br><span class="line">on e.dept_id = d.id</span><br><span class="line">join s_region r</span><br><span class="line">on d.region_id = r.id</span><br><span class="line">where r.name='Asia';</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出客户的id,名称,联系方式以及这个客户的订单信息</p><p>‘问题 - 15rows - [201,215]’</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,c.phone,o.* from s_customer c</span><br><span class="line">join s_ord o on c.id = o.customer_id;</span><br><span class="line"></span><br><span class="line">查询出来的结果缺了id=207和215俩个客户,因为这俩个客户没有订单,所以这俩个客户没有查询出来.</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="连接的方式"><a href="#连接的方式" class="headerlink" title="连接的方式"></a>连接的方式</h2><blockquote><ol><li><p>内连接 - [inner] join</p><p><code>如果join左边的表在右边的表中如果不存记录,则不会被查询出来.</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,c.phone,o.id from s_customer c</span><br><span class="line">inner join s_ord o on c.id = o.customer_id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>左连接 - left join</p><p><code>以左边的表为基准表.即使左边的表在右边的表中没有记录,那么左边表中的这条记录也要能够被查询出来</code></p><p><code>查询客户和订单信息,即使这个客户没有订单,那么这个客户也要能够被查询出来</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,c.phone,o.id from s_customer c</span><br><span class="line">left join s_ord o on c.id = o.customer_id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>右连接 - right join</p><p><code>以右边的表为基准表.即使右边的表在左边的表中没有记录,那么右边表中的这条记录也要能够被查询出来</code></p><p><code>查询客户和订单信息,即使这个客户没有订单,那么这个客户也要能够被查询出来</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,c.phone,o.id from s_ord o</span><br><span class="line">right join s_customer c on c.id = o.customer_id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>交叉连接 - cross join - 不会使用的,产生的是一个错误的结果集 - 笛卡尔积</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,c.phone,o.id from s_customer c</span><br><span class="line">cross join s_ord o;</span><br></pre></td></tr></tbody></table></figure></li><li><p>全连接 full outer join - mysql不支持</p><p>全连接 = 左连接 + 右连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">drop table t_info;</span><br><span class="line">create table t_user(</span><br><span class="line">id int primary key,</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into t_user values(1,'admin');</span><br><span class="line">insert into t_user values(2,'python');</span><br><span class="line"></span><br><span class="line">create table t_info(</span><br><span class="line">id int primary key,</span><br><span class="line">remark varchar(20),</span><br><span class="line">user_id int</span><br><span class="line">);</span><br><span class="line">insert into t_info values(1,'aaa',1);</span><br><span class="line">insert into t_info values(2,'bbb',3);</span><br><span class="line"></span><br><span class="line">-- 分析 - 左连接</span><br><span class="line">select u.*,info.* from t_user u left join t_info info on u.id = info.user_id;</span><br><span class="line">+----+--------+------+--------+---------+</span><br><span class="line">| id | name   | id   | remark | user_id |</span><br><span class="line">+----+--------+------+--------+---------+</span><br><span class="line">|  1 | admin  |    1 | aaa    |       1 |</span><br><span class="line">|  2 | python | NULL | NULL   |    NULL |</span><br><span class="line">+----+--------+------+--------+---------+</span><br><span class="line"></span><br><span class="line">-- 右连接</span><br><span class="line">select info.*,u.* from t_user u right join t_info info on u.id = info.user_id;</span><br><span class="line">+----+--------+---------+------+-------+</span><br><span class="line">| id | remark | user_id | id   | name  |</span><br><span class="line">+----+--------+---------+------+-------+</span><br><span class="line">|  1 | aaa    |       1 |    1 | admin |</span><br><span class="line">|  2 | bbb    |       3 | NULL | NULL  |</span><br><span class="line">+----+--------+---------+------+-------+</span><br><span class="line"></span><br><span class="line">-- 全连接</span><br><span class="line">union - 两张表中的重复的结果保留了一条 </span><br><span class="line"></span><br><span class="line">union all - 两张表中的重复的结果都会展示出来 , 并集</span><br><span class="line"></span><br><span class="line">select u.*,info.* from t_user u left join t_info info on u.id = info.user_id</span><br><span class="line">union all</span><br><span class="line">select u.*,info.* from t_user u right join t_info info on u.id = info.user_id;</span><br><span class="line"></span><br><span class="line"> id   | name   | id   | remark | user_id |</span><br><span class="line">+------+--------+------+--------+---------+</span><br><span class="line">|    1 | admin  |    1 | aaa    |       1 |</span><br><span class="line">|    2 | python | NULL | NULL   |    NULL |</span><br><span class="line">|    1 | admin  |    1 | aaa    |       1 |</span><br><span class="line">| NULL | NULL   |    2 | bbb    |       3 |</span><br><span class="line">+------+--------+------+--------+---------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select u.*,info.* from t_user u left join t_info info on u.id = info.user_id</span><br><span class="line">union </span><br><span class="line">select u.*,info.* from t_user u right join t_info info on u.id = info.user_id;</span><br><span class="line"></span><br><span class="line">+------+--------+------+--------+---------+</span><br><span class="line">| id   | name   | id   | remark | user_id |</span><br><span class="line">+------+--------+------+--------+---------+</span><br><span class="line">|    1 | admin  |    1 | aaa    |       1 |</span><br><span class="line">|    2 | python | NULL | NULL   |    NULL |</span><br><span class="line">| NULL | NULL   |    2 | bbb    |       3 |</span><br><span class="line">+------+--------+------+--------+---------+</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h3 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h3><blockquote><p>查询员工的名称以及他对应的上司的名称,即使这个员工没有上司,那么也要查询出来 - 自关联</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e1.first_name 员工,e2.first_name 上司</span><br><span class="line">from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id;</span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h1><blockquote><ol><li><p>count - 统计个数,null值不会统计,重复的数据,有一个算一个</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from s_emp;</span><br><span class="line"></span><br><span class="line">select count(e.id) from s_emp e;</span><br><span class="line"></span><br><span class="line">select count(e.commission_pct) from s_emp;//5个</span><br><span class="line"></span><br><span class="line">-- 统计职称的个数,但是重复的职称只能算1个</span><br><span class="line">select count(distinct title) from s_emp;</span><br></pre></td></tr></tbody></table></figure></li><li><p>sum - 总和,忽略null值</p></li><li><p>avg,max,min</p></li></ol></blockquote><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><blockquote><p><code>分组统计</code></p></blockquote><blockquote><p><code>语法</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT 语句</span><br><span class="line">WHERE 语句</span><br><span class="line">GROUP BY 语句</span><br><span class="line">HAVING 语句</span><br><span class="line">ORDER BY 语句</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><blockquote><ol><li><p>统计每个部门的员工的个数 - 单表</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.dept_id,count(e.id) from s_emp e group by e.dept_id;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>统计部门的id,name以及这个部门的员工的个数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- group by + d.id  --- ok   id是主键列 - 唯一性</span><br><span class="line">select d.id,d.name,count(e.id) from s_emp e</span><br><span class="line">join s_dept d on e.dept_id = d.id group by d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select d.id,d.name,count(e.id) from s_emp e</span><br><span class="line">join s_dept d on e.dept_id = d.id group by d.name;</span><br><span class="line">ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'dy.d.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br><span class="line"></span><br><span class="line">-- 推荐select后面跟的列(除了组函数/多行函数)应该和group by 跟的列保持一致</span><br><span class="line">select d.id,d.name,count(e.id) from s_emp e</span><br><span class="line">join s_dept d on e.dept_id = d.id group by d.id,d.name;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计每个职称的人数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title,count(*) from s_emp group by title;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计区域id,区域名,以及这个区域上的员工的个数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select r.id,r.name,count(e.id) from s_region r join s_dept d</span><br><span class="line">on d.region_id = r.id join s_emp e on e.dept_id = d.id group by r.id,r.name;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计客户的id,name以及这个客户的订单的数量,没有订单,则显示0</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,count(o.id) from s_customer c left join s_ord o</span><br><span class="line">on o.customer_id = c.id group by c.id,c.name;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计各年份入职的员工(年份,员工数量)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select year(start_date),count(e.id) from s_emp e</span><br><span class="line">group by year(start_date);</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h3 id="having使用方式"><a href="#having使用方式" class="headerlink" title="having使用方式"></a>having使用方式</h3><blockquote><p>having和where区别</p><ol><li>where条件筛选,但是分组之前,并且where不会跟组函数</li><li>having分组之后的进一步过滤,使用组函数进行过滤的</li></ol></blockquote><p><code>练习</code></p><blockquote><ol><li><p>查询出平均工资超过1300的部门 - 部门id,name,平均工资</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select d.id,d.name,avg(e.salary) from s_dept d join s_emp e</span><br><span class="line">on d.id = e.dept_id group by d.id,d.name having avg(e.salary)&gt;1300;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计除了’Asia’区域之外的各个区域的id,name和区域上的人数[大于3个],最后再根据区域的id进行降序排列</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select r.id,r.name,count(e.id) from s_region r </span><br><span class="line">join s_dept d on r.id = d.region_id</span><br><span class="line">join s_emp e on e.dept_id = d.id</span><br><span class="line">where r.name&lt;&gt;'Asia'</span><br><span class="line">group by r.id,r.name</span><br><span class="line">having count(e.id)&gt;3</span><br><span class="line">order by 1 desc;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询没有订单的客户</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,count(o.id) from s_customer c</span><br><span class="line">left join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)=0;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><blockquote><p>子查询必须使用()括起来</p><ul><li>条件列</li><li>查询列</li><li>子查询的结果看做是”一张表”</li></ul></blockquote><p><code>练习</code></p><blockquote><ol><li><p>查找和Mark工资一样的员工.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 分解 - mark工资 - 1450</span><br><span class="line">select salary from s_emp where first_name='Mark';</span><br><span class="line"></span><br><span class="line">-- 找出1450薪资的员工</span><br><span class="line">select first_name,salary from s_emp where salary = 1450 and first_name&lt;&gt;'Mark';</span><br><span class="line"></span><br><span class="line">-- 整合</span><br><span class="line">-- 子查询出现在条件部分</span><br><span class="line">select first_name,salary from s_emp where salary = (select salary from s_emp where first_name='Mark')  and first_name&lt;&gt;'Mark';</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计每个部门的id,name以及部门的员工的个数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select d.id,d.name,(</span><br><span class="line">select count(e.id) from s_emp e where e.dept_id = d.id</span><br><span class="line">) from s_dept d;</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><p><code>练习2</code></p><blockquote><ol><li>统计客户的id,name以及客户的订单数量</li></ol> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select c.id,c.name,(select count(o.id) from s_ord o where o.customer_id = c.id) from s_customer c;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>找出部门平均工资高于公司平均工资的部门信息</li></ol> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select dept_id,avg(salary) from s_emp group by dept_id having avg(salary)&gt;(select avg(salary) from s_emp);</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>找出与’Ben’同部门的员工信息</li></ol> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 方式一</span><br><span class="line">select first_name,dept_id from s_emp where dept_id=(select dept_id from s_emp where first_name='Ben')</span><br><span class="line">and first_name&lt;&gt;'Ben';</span><br><span class="line"></span><br><span class="line">-- 方式二</span><br><span class="line">select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name='Ben' and e1.dept_id=e.dept_id) did from s_emp e where e.first_name&lt;&gt;'Ben';</span><br><span class="line"></span><br><span class="line">-- 方式二整合 - 把子查询的结果作为一张表,必须要别名</span><br><span class="line">select * from (select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name='Ben' and e1.dept_id=e.dept_id) did from s_emp e where e.first_name&lt;&gt;'Ben') core_</span><br><span class="line">where core_.did is not null;</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li><p>能用分组查询查询就不要使用子查询(嵌套越多,查询效率越低)</p></li><li><p>无关子查询(子查询可以独立运行)和相关子查询(子查询使用到了外部查询的东西)</p><p>无关子查询&gt;相关子查询</p></li><li><p>子查询会比分组查询更加灵活.</p></li></ol></blockquote><h1 id="exists和not-exists"><a href="#exists和not-exists" class="headerlink" title="exists和not exists"></a>exists和not exists</h1><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT 语句</span><br><span class="line">WHERE exists (子查询)</span><br><span class="line"></span><br><span class="line">规则: 不关心子查询查到的内容是什么,子查询是否能够查询出结果.</span><br><span class="line">如果查询出结果,等同于where true</span><br><span class="line"></span><br><span class="line">select id,first_name from s_emp where exists(select 1 from s_emp where 1=1);</span><br></pre></td></tr></tbody></table></figure><p><code>找出和'Ben'同一个部门的员工</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.first_name,e.dept_id from s_emp e </span><br><span class="line">where exists(</span><br><span class="line">select 1 from s_emp e1 where e1.first_name='Ben' and e1.dept_id = e.dept_id</span><br><span class="line">) and e.first_name&lt;&gt;'Ben';</span><br></pre></td></tr></tbody></table></figure></blockquote><p><code>练习</code></p><blockquote><p>找出各个部门工资排名前二的员工</p><p>思路: 在’我’这个部门中,有人的工资比我高,但是数量不能超过1个</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.id,e.salary,e.dept_id from s_emp e</span><br><span class="line">where exists(</span><br><span class="line">select 1 from s_emp e1 where e1.dept_id = e.dept_id and</span><br><span class="line">e1.salary&gt;e.salary having count(*)&lt;=1</span><br><span class="line">) order by 3;</span><br></pre></td></tr></tbody></table></figure></blockquote><p><code>练习</code></p><blockquote><p>找出每个部门中工资最高的那个人</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库介绍&quot;&gt;&lt;a href=&quot;#数据库介绍&quot; class=&quot;headerlink&quot; title=&quot;数据库介绍&quot;&gt;&lt;/a&gt;数据库介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;按照一定的数据结构来组织,管理和存储数据的仓库&lt;/p&gt;
&lt;p&gt;用仓库的方式来管理数据的.一</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="数据库基础" scheme="https://apelisun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://apelisun.github.io/2022/08/09/%E7%B4%A2%E5%BC%95/"/>
    <id>https://apelisun.github.io/2022/08/09/%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-09T11:22:53.000Z</published>
    <updated>2022-08-10T03:53:20.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><ul><li><h4 id="create-view"><a href="#create-view" class="headerlink" title="create view"></a>create view</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop view student_view;</span><br><span class="line">create view student_view as select *from t_student where id%2=0;</span><br><span class="line"></span><br><span class="line">-- insert into t_student</span><br><span class="line">insert into t_student values(5,'java',20),(6,'javab',25),(7,'sad',20),(8,'jksd',56);</span><br><span class="line"></span><br><span class="line">-- update student_view</span><br><span class="line">update student_view set age=100 where id=8;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><h4 id="create-complex-view"><a href="#create-complex-view" class="headerlink" title="create complex view"></a>create complex view</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-- 有关系的两张表（fk）</span><br><span class="line">drop view student_view2;</span><br><span class="line">create view student_view2 as select s.*,sc.c_id from t_student s left join t_sc sc  on  s.id=sc.s_id;</span><br><span class="line"></span><br><span class="line">-- update view</span><br><span class="line">update student_view2 set name='as' ;</span><br><span class="line"></span><br><span class="line">ERROR 1288 (HY000): The target table student_view2 of the UPDATE is not updatable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 无关系的两张表</span><br><span class="line">drop table tt;</span><br><span class="line">drop table ta;</span><br><span class="line">create table tt(</span><br><span class="line"> id int(7) primary key,</span><br><span class="line">tname varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table ta(</span><br><span class="line"> taid int(7) primary key,</span><br><span class="line">tt_id int(7)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into tt values(1,'aa');</span><br><span class="line">insert into tt values(2,'aa');</span><br><span class="line">insert into tt values(3,'aa');</span><br><span class="line">insert into tt values(4,'aa');</span><br><span class="line"></span><br><span class="line">insert into ta values(1,1);</span><br><span class="line">insert into ta values(2,2);</span><br><span class="line">insert into ta values(3,3);</span><br><span class="line">insert into ta values(4,4);</span><br><span class="line">drop view t_view;</span><br><span class="line">create view t_view as select * from tt t join ta a on a.tt_id=t.id;</span><br><span class="line">update t_view set tname='as';</span><br><span class="line"></span><br><span class="line">create view t_view2 as select count(*)from tt t join ta a on a.tt_id=t.id;</span><br><span class="line">update t_view set count=10;</span><br><span class="line"></span><br><span class="line">视图作用：1.封装sql  2.屏蔽底层数据库结构  3.定制数据   4.安全性（grant）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- function:提高查询效率</span><br><span class="line">底层：b+数  myisam（数据，索引分别存储）,innodb(数据，索引合二为一)</span><br><span class="line">-- 主键列默认索引列</span><br><span class="line">show index from 表名</span><br><span class="line"></span><br><span class="line">-- 索引分类</span><br><span class="line">1.主键索引（primary key）</span><br><span class="line">2.unique</span><br><span class="line">3.全文索引（elasticsearch）</span><br><span class="line">4.复合索引</span><br><span class="line">create index index_name on tablename(column 1,column 2)</span><br><span class="line">5.普通索引</span><br><span class="line">create index index_name on tablename(colunmn)</span><br><span class="line"></span><br><span class="line">drop table index_test;</span><br><span class="line">create table index_test(</span><br><span class="line">id int(7) primary key auto_increment,</span><br><span class="line">a int(7),</span><br><span class="line">b int(7),</span><br><span class="line">c varchar(20),</span><br><span class="line">d varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into index_test values(1,2,3,'20w','cc'),(null,22,93,'2s0','dd'),(null,22,33,'w20','ss'),(null,22,53,'201','hh'),(null,72,43,'200','gg'),(null,2,3,'20i','ff');</span><br><span class="line"></span><br><span class="line">drop index t_index;</span><br><span class="line">create index t_index on index_test(a,b,c);</span><br><span class="line"></span><br><span class="line">-- jude index valid</span><br><span class="line">explain +select....</span><br><span class="line"></span><br><span class="line">explain select * from index_test where a=2 and b=3 and c='20w';(ref) len=93  </span><br><span class="line">+----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key     | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | index_test | NULL       | ref  | t_index       | t_index | 93      | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+</span><br><span class="line">-- 索引失效*</span><br><span class="line">1.复合索引最左匹配原则</span><br><span class="line">explain select *from index_test where b=3 and c='20w';(All len=0)</span><br><span class="line">explain select *from index_test where a=3 and b=2;(ref len=10)</span><br><span class="line">explain select *from index_test where c='sd' and a=10 and b=2;(ref len=93),调优</span><br><span class="line">2.模糊匹配</span><br><span class="line">-- %在末尾生效</span><br><span class="line">explain select * from index_test where a=1 and b=2 and c like 's%';(ref len=93)</span><br><span class="line">%在前部分生效同（%？%）</span><br><span class="line">explain select * from index_test where a=1 and b=2 and c like '%s';(ref len=10)-- a,b走索引</span><br><span class="line">3.查询范围</span><br><span class="line">explain select * from index_test where a=1 and b&gt;2 and c='21';(ref len=10)</span><br><span class="line">4.索引计算</span><br><span class="line">explain select* from index_test where id+1=1;(all)</span><br><span class="line">5.索引使用函数</span><br><span class="line">explain select* from index_test where abs(id)=1;(all)</span><br><span class="line">6.c查询数据超过百分之30（数据量足够大）</span><br><span class="line">7.is null and is not null</span><br><span class="line">(is null 不走索引，is not null 走索引)</span><br><span class="line">8.in and not in</span><br><span class="line">before 5.7 in(走索引)  not in(不走)</span><br><span class="line">after 8.0 not in ( allow index)</span><br><span class="line"></span><br><span class="line">-- 索引的创建策略</span><br><span class="line">-- fit create index</span><br><span class="line">1.primary key or unique</span><br><span class="line">2.重复性少，经常被查询，但是更新少</span><br><span class="line">3.order by 列</span><br><span class="line">4.join on 列</span><br><span class="line">-- unfit create index</span><br><span class="line">1.null值列</span><br><span class="line">2.重复列</span><br><span class="line">3.更新频繁列</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.行锁（两线程不能同时修改某一行的值）</span><br><span class="line">update XX set xx=xx where id=1;//必须是索引列，降低锁的粒度</span><br><span class="line">2.表锁（非索引列为条件更新 会触发表锁）</span><br><span class="line">所有的DML操作都会阻塞</span><br><span class="line">3.页锁（介于行锁与表锁之间）</span><br><span class="line">一页：由若干行组成的数据（B+树）</span><br><span class="line">4.共享锁（select,类似Java的读锁）</span><br><span class="line">-- select语句申请排他锁</span><br><span class="line">select stock from xxx where id=1 for update;（悲观锁：干啥都悲观，总担心有人改数据，索性给全锁了）</span><br></pre></td></tr></tbody></table></figure><h3 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">myisam(mai se meng),innoDB-----&gt;B+树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二叉查找树-&gt;二叉搜索树-&gt;B+树</span><br><span class="line"></span><br><span class="line">二叉查找树（失衡）--&gt;（产生）二叉平衡树（数据节点过多）-&gt;B树（储存一页数据，key和value都存）-&gt;b+树</span><br><span class="line"></span><br><span class="line">B+树</span><br><span class="line">1.非页节点存储key</span><br><span class="line">2.数据存叶子，且相对有序</span><br><span class="line">3.页与页（树节点）之间是双向链表</span><br><span class="line">4.叶子内部数据是单向链表</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>– 聚簇索引</p><p><img src="/B+.jpg" alt="B+"></p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">innoDB为引擎的表，表中的数据都会有主键，即使不主动声明，系统会创建一个隐式的主键.B+树的键值就是主键.这种**以主键为B+树索引而构成的B+树***索引，称为聚簇索引</span><br><span class="line"></span><br><span class="line">非聚簇索引：以其他列值构建B+树的索引</span><br><span class="line"></span><br><span class="line">-- 非聚集索引的叶子节点并不存储数据，而是存储对应的主键，因此还需要通过索引查数据，称之为回表</span><br><span class="line">（注，若所查数据为主键列，或者该列，则不需要回表）</span><br></pre></td></tr></tbody></table></figure><p><img src="C:\Users\liming\Desktop\jusearch.jpg" alt="jusearch"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xx where id&gt;=18 and id&lt;41;</span><br></pre></td></tr></tbody></table></figure><h3 id="非聚簇索引查找图"><a href="#非聚簇索引查找图" class="headerlink" title="非聚簇索引查找图"></a>非聚簇索引查找图</h3><p><img src="/x.png" alt="x"></p><h3 id="myisam查找图"><a href="#myisam查找图" class="headerlink" title="myisam查找图"></a>myisam查找图</h3><p><img src="/z.png" alt="z"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">key - 索引列值,value - 数据行的物理地址.</span><br><span class="line">innodb中索引和数据合并到一个文件中</span><br><span class="line"></span><br><span class="line">myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件.</span><br><span class="line"></span><br><span class="line">myisam中采用的是"非聚集的方式"</span><br><span class="line"></span><br><span class="line">无论是聚簇索引还是非聚簇索引,查找方式是一样.</span><br><span class="line"></span><br><span class="line">采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.**</span><br><span class="line"></span><br><span class="line">需要再根据行记录地址到表中进行定位[回表]</span><br></pre></td></tr></tbody></table></figure><ul><li><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create function dy_add(a int ,b int) returns int</span><br><span class="line">begin</span><br><span class="line">return a+b;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select dy_add(5,2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create function dy_add(a int ,b int) returns int</span><br><span class="line">begin</span><br><span class="line">return a+b;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">select dy_add(5,2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 触发器</span><br><span class="line">drop trigger customer_trriger;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger  customer_trriger </span><br><span class="line">     before delete on s_customer </span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">delete from s_ord where customer_id=old.id;</span><br><span class="line">end //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 触发器</span><br><span class="line">drop trigger customer_trriger;</span><br><span class="line">delimiter //</span><br><span class="line">create trigger  customer_trriger </span><br><span class="line">     before insert on s_customer </span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">if new.id&lt;5</span><br><span class="line">select 'error';</span><br><span class="line">end //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;view&quot;&gt;&lt;a href=&quot;#view&quot; class=&quot;headerlink&quot; title=&quot;view&quot;&gt;&lt;/a&gt;view&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;create-view&quot;&gt;&lt;a href=&quot;#create-view&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="index" scheme="https://apelisun.github.io/tags/index/"/>
    
  </entry>
  
  <entry>
    <title>mysql四种分区</title>
    <link href="https://apelisun.github.io/2022/08/08/mysql%E5%9B%9B%E7%A7%8D%E5%88%86%E5%8C%BA/"/>
    <id>https://apelisun.github.io/2022/08/08/mysql%E5%9B%9B%E7%A7%8D%E5%88%86%E5%8C%BA/</id>
    <published>2022-08-08T13:04:23.000Z</published>
    <updated>2022-08-10T03:51:25.690Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">drop table t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int(7) primary key comment '主键',</span><br><span class="line">name varchar(20) not null unique comment '姓名',</span><br><span class="line">birthday date default '2022-02-08'</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">drop table t_account;</span><br><span class="line">create table t_account(</span><br><span class="line">id int(7),</span><br><span class="line">blance double(5,2),</span><br><span class="line">u_id int(7) ,</span><br><span class="line">constraint t_account_id_pk primary key(id),</span><br><span class="line">constraint t_account_id_fk foreign key(u_id) references t_user(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drop table t_student;</span><br><span class="line">drop table t_course;</span><br><span class="line">drop table t_sc</span><br><span class="line"></span><br><span class="line">create table t_student(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20) unique not null,</span><br><span class="line">age int(7) default 20</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table t_course(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table t_sc(</span><br><span class="line">id int(7),</span><br><span class="line">s_id int (7),</span><br><span class="line">c_id int(7),</span><br><span class="line">constraint t_sc_id_pk primary key(id),</span><br><span class="line">constraint t_sc_s_id_fk foreign key(s_id) references t_student(id),</span><br><span class="line">constraint t_sc_c_id_fk foreign key(c_id) references t_course(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_student values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null);</span><br><span class="line">insert into t_course values(1,'math'),(2,'english'),(3,'chinses'),(4,'chesmatical');</span><br><span class="line">insert into t_sc values(1,1,1),(2,2,3),(3,4,2),(4,3,4);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--测试表格及数据</span><br><span class="line">drop table hashTest;</span><br><span class="line">create table hashTest(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">age int(7)</span><br><span class="line">)PARTITION BY HASH(id) PARTITIONS 4;;</span><br><span class="line">insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);</span><br><span class="line"></span><br><span class="line">--查询分区结构</span><br><span class="line">SELECT PARTITION_NAME,PARTITION_METHOD,PARTITION_EXPRESSION,PARTITION_DESCRIPTION,TABLE_ROWS</span><br><span class="line">FROM `information_schema`.`PARTITIONS`</span><br><span class="line">WHERE TABLE_SCHEMA=SCHEMA() AND TABLE_NAME='hashTest';</span><br></pre></td></tr></tbody></table></figure><h3 id="hash分区-PARTITIONS-x3D-4-4个分区，根据取模确定不同id的占据区域"><a href="#hash分区-PARTITIONS-x3D-4-4个分区，根据取模确定不同id的占据区域" class="headerlink" title="hash分区 PARTITIONS=4(4个分区，根据取模确定不同id的占据区域)"></a>hash分区 PARTITIONS=4(4个分区，根据取模确定不同id的占据区域)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| p0             | HASH             | `id`                 | NULL                  |          3 |</span><br><span class="line">| p1             | HASH             | `id`                 | NULL                  |          3 |</span><br><span class="line">| p2             | HASH             | `id`                 | NULL                  |          3 |</span><br><span class="line">| p3             | HASH             | `id`                 | NULL                  |          3 |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Range分区-分成6个分区"><a href="#Range分区-分成6个分区" class="headerlink" title="Range分区 分成6个分区"></a>Range分区 分成6个分区</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">drop table hashTest;</span><br><span class="line">create table hashTest(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">age int(7)</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (id) PARTITIONS 6 (</span><br><span class="line">    PARTITION part0 VALUES LESS THAN (2) , </span><br><span class="line">    PARTITION part1 VALUES LESS THAN (4) , </span><br><span class="line">    PARTITION part2 VALUES LESS THAN (6) , </span><br><span class="line">    PARTITION part3 VALUES LESS THAN (8) , </span><br><span class="line">    PARTITION part4 VALUES LESS THAN (10),</span><br><span class="line">    PARTITION part5 VALUES LESS THAN (13)</span><br><span class="line">);</span><br><span class="line">insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);</span><br><span class="line"></span><br><span class="line">分区结果：</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| part0          | RANGE            | `id`                 | 2                     |          1 |</span><br><span class="line">| part1          | RANGE            | `id`                 | 4                     |          2 |</span><br><span class="line">| part2          | RANGE            | `id`                 | 6                     |          2 |</span><br><span class="line">| part3          | RANGE            | `id`                 | 8                     |          2 |</span><br><span class="line">| part4          | RANGE            | `id`                 | 10                    |          2 |</span><br><span class="line">| part5          | RANGE            | `id`                 | 13                    |          3 |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br></pre></td></tr></tbody></table></figure><h3 id="list分区"><a href="#list分区" class="headerlink" title="list分区"></a>list分区</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drop table hashTest;</span><br><span class="line">create table hashTest(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">age int(7)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">PARTITION BY LIST(id) (</span><br><span class="line">    PARTITION pNorth VALUES IN (1,2,3),</span><br><span class="line">    PARTITION pEast VALUES IN (5,6,7),</span><br><span class="line">    PARTITION pWest VALUES IN (4,8,9),</span><br><span class="line">    PARTITION pCentral VALUES IN (10,11,12)</span><br><span class="line">);</span><br><span class="line">insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);</span><br><span class="line">--分区结果：</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| pCentral       | LIST             | `id`                 | 10,11,12              |          3 |</span><br><span class="line">| pEast          | LIST             | `id`                 | 5,6,7                 |          3 |</span><br><span class="line">| pNorth         | LIST             | `id`                 | 1,2,3                 |          3 |</span><br><span class="line">| pWest          | LIST             | `id`                 | 4,8,9                 |          3 |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br></pre></td></tr></tbody></table></figure><h3 id="key分区（和hash分区类似，其分区函数是由mysql内部确定的）"><a href="#key分区（和hash分区类似，其分区函数是由mysql内部确定的）" class="headerlink" title="key分区（和hash分区类似，其分区函数是由mysql内部确定的）"></a>key分区（和hash分区类似，其分区函数是由mysql内部确定的）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drop table hashTest;</span><br><span class="line">create table hashTest(</span><br><span class="line">id int(7) primary key,</span><br><span class="line">name varchar(20),</span><br><span class="line">age int(7)</span><br><span class="line">)</span><br><span class="line">PARTITION BY KEY()</span><br><span class="line">PARTITIONS 2;</span><br><span class="line">insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);</span><br><span class="line"></span><br><span class="line">--分区结果</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br><span class="line">| p0             | KEY              | NULL                 | NULL                  |          6 |</span><br><span class="line">| p1             | KEY              | NULL                 | NULL                  |          6 |</span><br><span class="line">+----------------+------------------+----------------------+-----------------------+------------+</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="msql" scheme="https://apelisun.github.io/tags/msql/"/>
    
    <category term="area" scheme="https://apelisun.github.io/tags/area/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://apelisun.github.io/2022/08/08/%E9%9B%86%E5%90%88/"/>
    <id>https://apelisun.github.io/2022/08/08/%E9%9B%86%E5%90%88/</id>
    <published>2022-08-08T13:03:53.000Z</published>
    <updated>2022-08-10T03:53:10.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><p>就是一个内存中的”容器”,用来存储数据.实际开发中用来替代数组的使用</p><p>不同的集合框架底层使用到的数据结构不一样.</p></blockquote><blockquote><p>api包:java.util</p><ol><li><p>Collection[I]</p><ul><li><p>List[I]  - 有序,可重复</p><ul><li><p>ArrayList[C] - “底层就是动态数组 - 内存中是连续的,有序的 - 便于使用下标来访问元素.但是增删效率略低”</p></li><li><p>LinkedList[C] - “底层是一个双向链表,访问比ArrayList慢,但是增删效率高”</p><p>适合解决栈列和队列的业务 - 贪吃蛇</p></li><li><p>Vector[C] - 线程安全的,使用方式和ArrayList一致.</p></li></ul></li><li><p>Set[I] - 无序,不可重复</p><ul><li><p>HashSet[C] - “底层使用的哈希算法,底层就是HashMap”</p></li><li><p>SortedSet[I]</p><ul><li><p>TreeSet[C] - “可以使用可比较接口或者比较器接口来实现排序的功能,但是仍然是不可重复的”</p><p>“底层是TreeMap”</p></li></ul></li></ul></li></ul></li><li><p>Map[I] - 采用key-value键值对形式来存储数据</p><ul><li>HashMap[C] - 针对key无序不可重复</li><li>Hashtable[C]<ul><li>Properties[C] - .properties属性文件在内存中映射的那个对象</li></ul></li></ul></li></ol></blockquote><h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><blockquote><p>作用 - 为了访问不同数据结构的集合,提供了一种统一的方式.</p></blockquote><p><code>ArrayList</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">            checkForComodification();<span class="comment">//检测expectedModCount == modCount;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="comment">//集合存储的数据</span></span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i]; <span class="comment">// 数组对象[下标]</span></span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>LinkedList</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">                <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            } <span class="keyword">catch</span> (IndexOutOfBoundsException e) {</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="ArrayList练习"><a href="#ArrayList练习" class="headerlink" title="ArrayList练习"></a>ArrayList练习</h1><blockquote><p>集合中添加N个图书对象,将图书名包含java的图书全部删除!</p></blockquote><h1 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h1><blockquote><ul><li>第一次调用add方法的时候,才会初始化数组elementData</li><li>默认的数组的长度是10个</li><li>扩容的倍数是1.5倍</li></ul></blockquote><h1 id="ArrayList和Vector区别"><a href="#ArrayList和Vector区别" class="headerlink" title="ArrayList和Vector区别"></a>ArrayList和Vector区别</h1><blockquote><p>要想回答这个问题，可以先把各种都讲特性，然后再从底层存储结构，线程安全，默认大小，扩容机制，迭代器，增删改查效率这几个方向入手。</p><ul><li><p>底层存储数据结构 - <strong>本质上都是数组</strong>,Vector是使用队列[先进先出]来存储数据,但是本质仍然是数组.</p></li><li><p>线程安全性 - 前者是线程不安全,后者是线程安全</p></li><li><p>默认大小 - 俩者都是长度为10</p></li><li><p>扩容机制 - 前者是1.5倍,后者默认是扩容2倍,可以扩容系数可以设置的.</p></li><li><p><code>ArrayList</code>和<code>Vector</code>检索元素，由于是数组，时间复杂度是<code>O(1)</code>，在集合的尾部插入或者删除是<code>O(1)</code>，但是其他的地方增加，删除，都是<code>O(n)</code>，因为涉及到了数组元素的移动</p><p><code>ArrayList的删除和插入的效率一定会比LinkedList低吗?</code> - 不一定,看是否操作的是集合的尾部</p></li></ul></blockquote><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><blockquote><p>jdk8.0用到的是双向链表结构</p><p>链表肯定会比数组占用更多的内存</p></blockquote><blockquote><p>阔以模拟栈列和队列的业务</p></blockquote><blockquote><p>单向链表结构 - 必须从头节点开始</p><p>element - 真实的数据</p><p>next - 下一个节点的地址</p></blockquote><blockquote><p><img src="/imgs/link01.png"> </p></blockquote><blockquote><p>单向循环结构</p><p><img src="/imgs/link02.png"> </p></blockquote><blockquote><p><img src="/imgs/link03.png"> </p></blockquote><blockquote><p> <img src="/imgs/link04.png"> </p></blockquote><h2 id="get-int-index-底层"><a href="#get-int-index-底层" class="headerlink" title="get(int index)底层"></a>get(int index)底层</h2><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">checkElementIndex(index);</span><br><span class="line"><span class="keyword">return</span> node(index).item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>内部类</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">E item;</span><br><span class="line">Node&lt;E&gt; next;</span><br><span class="line">Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line"> <span class="built_in">this</span>.item = element;</span><br><span class="line"> <span class="built_in">this</span>.next = next;</span><br><span class="line"> <span class="built_in">this</span>.prev = prev;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>核心方法node(index)</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line"><span class="comment">// index=2</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 = size = 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) { <span class="comment">// 如果在中间位置的左边</span></span><br><span class="line"> Node&lt;E&gt; x = first; <span class="comment">// 头节点开始遍历</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">   x = x.next;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// 从尾部</span></span><br><span class="line"> Node&lt;E&gt; x = last;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">   x = x.prev;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="remove-int-index-底层"><a href="#remove-int-index-底层" class="headerlink" title="remove(int index)底层"></a>remove(int index)底层</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>unlink(node(index));</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> { <span class="comment">// x-即将删除的节点</span></span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev; <span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="literal">null</span>) { <span class="comment">// 判断x是否为头节点</span></span><br><span class="line">    first = next; <span class="comment">// 原来第二个节点设置成头节点</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    prev.next = next; <span class="comment">//原来上一个节点的下一个地址应该指向原来这个节点的下一个节点</span></span><br><span class="line">    x.prev = <span class="literal">null</span>;<span class="comment">//gc</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="literal">null</span>) { <span class="comment">// 判断x是否为尾节点</span></span><br><span class="line">    last = prev; <span class="comment">// 倒数第二个节点设置成尾结点</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    x.next = <span class="literal">null</span>;<span class="comment">//gc</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  x.item = <span class="literal">null</span>;<span class="comment">//gc</span></span><br><span class="line">  size--; <span class="comment">// 集合的长度</span></span><br><span class="line">  modCount++; <span class="comment">// 并发修改</span></span><br><span class="line">  <span class="keyword">return</span> element;<span class="comment">//返回刚刚删除的元素</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><blockquote><ol><li><p>括号匹配</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line">[]</span><br><span class="line">{}</span><br><span class="line">()[]{}</span><br><span class="line">([{}])</span><br><span class="line">[()]{}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(]</span><br><span class="line">([)]{}</span><br><span class="line">​~~~java</span><br></pre></td></tr></tbody></table></figure><p>arr = ( [ { } ] )</p><p>永远将第一个元素压入栈顶 push<br>从arr的第2个位置开始遍历<br>i下标对应的元素,和栈顶元素进行比较getFast();<br>不匹配 - 继续压入栈顶<br>匹配 - 弹出栈顶<br>集合是否为空 isEmpty();</p><p>( [ ) ] { }</p><p>]<br>)<br>[<br>(</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Purcase</span>{ <span class="comment">//购买类</span></span><br><span class="line"><span class="keyword">private</span> String brand; <span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">//产品名</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> cost; <span class="comment">// 费用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造,getter/setter,toString...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">List&lt;Purcase&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"宝洁"</span>,<span class="string">"洗手粉"</span>,<span class="number">18.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"联合利华"</span>,<span class="string">"肥皂"</span>,<span class="number">4.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"宝洁"</span>,<span class="string">"牙膏"</span>,<span class="number">32.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"宝洁"</span>,<span class="string">"毛巾"</span>,<span class="number">14.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"洁利"</span>,<span class="string">"洗面奶"</span>,<span class="number">26.0</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"好迪"</span>,<span class="string">"洗发水"</span>,<span class="number">27.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"多芬"</span>,<span class="string">"沐浴露"</span>,<span class="number">38.5</span>);</span><br><span class="line"><span class="type">Purcase</span> <span class="variable">p8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purcase</span>(<span class="string">"宝洁"</span>,<span class="string">"洗洁精"</span>,<span class="number">3.4</span>);</span><br><span class="line"></span><br><span class="line">list.add(p1);</span><br><span class="line">list.add(p2);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">要求:写一个程序,打印出各品牌所花费的总费用①.</span><br><span class="line">[可选,排好序后再打印输出,按花费总费用的降序排序②]</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>map =&gt; 统计每个随机数出现的次数.      15个随机数     1~5</p><p>“python java 123 15901121 dfdfd  fdfd”</p></blockquote><h1 id="贪吃蛇的实现步骤"><a href="#贪吃蛇的实现步骤" class="headerlink" title="贪吃蛇的实现步骤"></a>贪吃蛇的实现步骤</h1><blockquote><ol><li><p>输出一个主界面</p><p>蛇身(LinkedList-&gt;存储了N个Node) - 长度,蛇头,方向</p><p><strong>随机生成n个食物</strong> - 使用HashSet来进行存储</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* * * * * * * * * * *</span><br><span class="line">* <span class="number">0</span></span><br><span class="line">*   # # # </span><br><span class="line">*     <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">*</span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>创建一个对象Node(int x,int y);</p></li><li><p>创建一个类SnakeGame</p><p>3-1. 创建一个内部类Snake - 维护一个LinkedList</p><p>3-2. Set<node> foods = new HashSet&lt;&gt;();//存放食物</node></p></li></ol></blockquote><blockquote><ol start="4"><li><p>走一步算法</p><p>4-1. 没有吃到食物</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 确定新的方向 - w a s d</span><br><span class="line"><span class="number">2.</span> 新的坐标Node(i,j)</span><br><span class="line"><span class="number">3.</span> addFirst - 将新的坐标放入到蛇头</span><br><span class="line"><span class="number">4.</span> 判断新的坐标是否属于foods,如果不属于removeLast();<span class="comment">//删除最后尾节点</span></span><br></pre></td></tr></tbody></table></figure><p>4-2. 吃到食物</p></li></ol></blockquote><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><blockquote><p>HashSet和HashMap =&gt; 存放数据的性能 - HashMap更高 - HashSet可能是计算整个对象的hashCode方法</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Book&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> {</span><br><span class="line">  map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">set.add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//set集合的value就是map集合的key</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">  <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><blockquote><p>线程不安全的.</p></blockquote><blockquote><p>用到的数据结构</p><p>jdk8.0-开始<strong>桶数组 + 单向链表 + 红黑树</strong></p><p><code>桶 - 哈希桶</code></p></blockquote><h2 id="put底层源码剖析"><a href="#put底层源码剖析" class="headerlink" title="put底层源码剖析"></a>put底层源码剖析</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容因子 - 预扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> {</span><br><span class="line">  <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//put方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对ke进行一个hash算法 - 扰动函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 让哈希值和高16位进行异或运算</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> {</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//①进来table和tab都是null</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//①就会执行扩容操作 n = 16  tab初始化完毕</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">//①hash - key的扰动函数得到哈希值</span></span><br><span class="line">  <span class="comment">//(n - 1) &amp; hash =&gt; 1. 下标肯定不会越界  2. 减少哈希冲突</span></span><br><span class="line">      <span class="comment">//p = tab[哈希位置]肯定是null</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//①对这个位置进行赋值操作</span></span><br><span class="line">            <span class="comment">//单向链表</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);<span class="comment">//最后一个参数是next</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//p - 哈希冲突的位置上的Node</span></span><br><span class="line">            <span class="comment">//比较node对象的hash值</span></span><br><span class="line">          </span><br><span class="line">             <span class="comment">//俩个确实是同一个对象</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;<span class="comment">//e = p是旧的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//OO - 不同对象的hashCode值,不一定 </span></span><br><span class="line">                <span class="comment">// 哈希碰撞了,但是并不是俩个相同的对象</span></span><br><span class="line">               <span class="comment">//b. 相同对象equals肯定返回true</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                    <span class="comment">//把哈希冲突位置上的旧节点p的next挂载一个新的e</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) {<span class="comment">//①肯定为空</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//当链表长度开始&gt;=8的时候,单向链表结构就会转换成红黑树</span></span><br><span class="line">                        <span class="comment">//删除操作 - 如果节点个数小于等于6的时候,开始转成链表结构</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//链表的节点可能和新插入的节点是一个相同对象</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;<span class="comment">//就是旧的节点的value</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;<span class="comment">//新的value赋值给旧节点的value</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><code>扩容resize()</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">  <span class="comment">//第一次进来oldTab就是null</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//oldCap 旧容量 = 0</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">//oldThr = 0</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//新的容量,新的扩容因子</span></span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">//newCap = 16</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">//newThr = 16*0.75f  =&gt; 扩容的临界值</span></span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//threshold = 16*0.75f</span></span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">  <span class="comment">//newTab 长度就是16</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) {</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> {</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            }</span><br><span class="line">          } <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) {</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) {</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h2><p><img src="/imgs/put.png"> </p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><ol><li>通过比较器接口java.util.Comparator<t></t></li><li>通过java.lang.Comparable[I]</li></ol></blockquote><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><blockquote><ol><li><p>List和Set区别</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、List,Set都是继承自Collection接口</span><br><span class="line">2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） </span><br><span class="line">3.Set和List对比： </span><br><span class="line">Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 </span><br><span class="line">List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 </span><br></pre></td></tr></tbody></table></figure></li><li><p>ArrayList和LinkedList区别</p></li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。</span><br><span class="line">对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。</span><br><span class="line">新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。</span><br><span class="line">LinkedList集合不支持 高效的随机随机访问（RandomAccess）</span><br><span class="line">ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</span><br></pre></td></tr></tbody></table></figure><ol><li>ArrayList和Vector区别</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">（1）同步性：</span><br><span class="line">Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它                    </span><br><span class="line"></span><br><span class="line">的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程                 </span><br><span class="line"></span><br><span class="line">安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编                  </span><br><span class="line"></span><br><span class="line">写线程安全的代码。</span><br><span class="line">（2）数据增长：</span><br><span class="line">ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需                </span><br><span class="line"></span><br><span class="line">要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存                      </span><br><span class="line"></span><br><span class="line">储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原                              </span><br><span class="line">来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。                          </span><br><span class="line"></span><br><span class="line">ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提              </span><br><span class="line"></span><br><span class="line">供设置增长空间的方法。</span><br></pre></td></tr></tbody></table></figure><ol><li>HashSet和HashMap区别</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</span><br><span class="line"></span><br><span class="line">(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</span><br><span class="line">(3)当使用无参构造创建 HashSet对象时, 其实调用了 HashMap的无参构造创建了一个 HashMap对象, 所以 HashSet 的初始化容量也为16, 负载因子也为 0.75.</span><br></pre></td></tr></tbody></table></figure><ol><li>TreeSet和TreeMap区别</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TreeMap 和 TreeSet 是 Java Collection Framework 的两个重要成员，其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 TreeMap 和TreeSet 实现的接口规范不同，但 TreeSet 底层是通过 TreeMap 来实现的（如同HashSet底层是是通过HashMap来实现的一样），因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法</span><br><span class="line"></span><br><span class="line">TreeSet和TreeMap的关系</span><br><span class="line"></span><br><span class="line">　　与HashSet完全类似，TreeSet里面绝大部分方法都市直接调用TreeMap方法来实现的。</span><br><span class="line"></span><br><span class="line">相同点：</span><br><span class="line"></span><br><span class="line">TreeMap和TreeSet都是非同步集合，因此他们不能在多线程之间共享，不过可以使用方法Collections.synchroinzedMap()来实现同步</span><br><span class="line">运行速度都要比Hash集合慢，他们内部对元素的操作时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。</span><br><span class="line">TreeMap和TreeSet都是有序的集合，也就是说他们存储的值都是拍好序的。</span><br><span class="line">不同点：</span><br><span class="line"></span><br><span class="line">最主要的区别就是TreeSet和TreeMap分别实现Set和Map接口</span><br><span class="line">TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序）</span><br><span class="line">TreeSet中不能有重复对象，而TreeMap中可以存在</span><br><span class="line">TreeMap的底层采用红黑树的实现，完成数据有序的插入，排序。</span><br></pre></td></tr></tbody></table></figure><ol><li>HashMap和Hashtable[线程安全]区别</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程安全性不同。HashMap线程不安全；Hashtable 中的方法是Synchronize的。</span><br><span class="line">key、value是否允许null。HashMap的key和value都是可以是null，key只允许一个null；Hashtable的key和value都不可为null。</span><br><span class="line">迭代器不同。HashMap的Iterator是fail-fast迭代器；Hashtable还使用了enumerator迭代器。</span><br><span class="line">hash的计算方式不同。HashMap计算了hash值；Hashtable使用了key的hashCode方法。</span><br><span class="line">默认初始大小和扩容方式不同。HashMap默认初始大小16，容量必须是2的整数次幂，扩容时将容量变为原来的2倍；Hashtable默认初始大小11，扩容时将容量变为原来的2倍加1。</span><br><span class="line">是否有contains方法。HashMap没有contains方法；Hashtable包含contains方法，类似于containsValue。</span><br><span class="line">父类不同。HashMap继承自AbstractMap；Hashtable继承自Dictionary。</span><br></pre></td></tr></tbody></table></figure><ol><li>Collection和Collections[集合工具类]区别</li></ol><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</span><br><span class="line"></span><br><span class="line">List，Set，Queue接口都继承Collection。</span><br><span class="line">直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。</span><br><span class="line"></span><br><span class="line">2、java.util.Collections 是一个包装类。 它包含有各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等），大多数方法都是用来处理线性表的。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><blockquote><ol><li><p>利用通过java.lang.Comparable[I]</p><p>对象去实现这个接口,并且重写comparaTo方法</p></li><li><p>利用构造器中可以传入一个比较器接口  =&gt; 更加灵活一点</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> {</span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型符号"><a href="#泛型符号" class="headerlink" title="泛型符号"></a>泛型符号</h2><blockquote><p>? </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="literal">null</span>);<span class="comment">//只能添加null</span></span><br></pre></td></tr></tbody></table></figure><p>K,V - 键,值</p><p>T - 类型</p><p>E - 元素</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><ol><li><p>泛型类</p></li><li><p>泛型方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(T t)</span>{</span><br><span class="line">  System.out.println(<span class="string">"find:"</span>+t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(T t)</span>{</span><br><span class="line">  System.out.println(<span class="string">"find:"</span>+t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">find2</span><span class="params">(T t)</span>{</span><br><span class="line">  System.out.println(<span class="string">"find:"</span>+t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="泛型好处"><a href="#泛型好处" class="headerlink" title="泛型好处"></a>泛型好处</h2><blockquote><p>1、类型安全</p><p>泛型的主要目标是提高Java程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在非常高的层次上验证类型假设。没有泛型，这些假设就只存在于系统开发人员的头脑中。</p><p>通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误就可以在编译时被捕获了，而不是在运行时当作ClassCastException展示出来。将类型检查从运行时挪到编译时有助于Java开发人员更早、更容易地找到错误，并可提高程序的可靠性。</p><p>2、消除强制类型转换</p><p>泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。尽管减少强制类型转换可以提高使用泛型类的代码的累赞程度，但是声明泛型变量时却会带来相应的累赞程度。在简单的程序中使用一次泛型变量不会降低代码累赞程度。但是对于多次使用泛型变量的大型程序来说，则可以累积起来降低累赞程度。所以泛型消除了强制类型转换之后，会使得代码加清晰和筒洁。</p><p>3、更高的运行效率</p><p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p><p>4、潜在的性能收益</p><p>泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，Java系统开发人员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的JVM的优化带来可能。</p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridde</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student s)</span>{</span><br><span class="line">  <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.getSession();</span><br><span class="line"></span><br><span class="line">  <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">  tx.save(s);</span><br><span class="line"></span><br><span class="line">  tx.commit();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overridde</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">getById</span><span class="params">(<span class="type">int</span> id)</span>{</span><br><span class="line">  <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.getSession();</span><br><span class="line"></span><br><span class="line">  <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">  <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> session.get(Student.class,id);</span><br><span class="line"></span><br><span class="line">  tx.commit();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span>{</span><br><span class="line">    Teacher <span class="title function_">getById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">  </span><br><span class="line">    List&lt;Teacher&gt; <span class="title function_">loadAll</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">save</span><span class="params">(Teacher t)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentDao</span>{</span><br><span class="line">    Student <span class="title function_">getById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">  </span><br><span class="line">    List&lt;Student&gt; <span class="title function_">loadAll</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="title function_">save</span><span class="params">(Student s)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑抽离出顶级的接口出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBaseDao</span>&lt;T&gt; {</span><br><span class="line">    T <span class="title function_">getById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;T&gt; <span class="title function_">loadAll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">save</span><span class="params">(T t)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶级接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDaoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">IBaseDao</span>&lt;T&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getById</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">        <span class="comment">//具体的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">loadAll</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//具体的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(T t)</span> {</span><br><span class="line">        <span class="comment">//具体的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定业务接口特有的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentDao</span> <span class="keyword">extends</span> <span class="title class_">IBaseDao</span>&lt;Student&gt;{  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDaoImpl</span>&lt;Student&gt; <span class="keyword">implements</span> <span class="title class_">IStudentDao</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="指定上限和下限"><a href="#指定上限和下限" class="headerlink" title="指定上限和下限"></a>指定上限和下限</h2><blockquote><ol><li><p>指定下限</p><p>泛型参数可以是E,也可以是E的父类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="built_in">super</span> E</span><br></pre></td></tr></tbody></table></figure></li><li><p>指定上限</p><p>泛型参数可以是E,也可以是E的子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">extends</span> <span class="title class_">E</span></span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><p>泛型是没有多态的.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合框架&quot;&gt;&lt;a href=&quot;#集合框架&quot; class=&quot;headerlink&quot; title=&quot;集合框架&quot;&gt;&lt;/a&gt;集合框架&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;就是一个内存中的”容器”,用来存储数据.实际开发中用来替代数组的使用&lt;/p&gt;
&lt;p&gt;不同的集合框架</summary>
      
    
    
    
    
    <category term="java" scheme="https://apelisun.github.io/tags/java/"/>
    
    <category term="collection" scheme="https://apelisun.github.io/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>sql常用查询‘</title>
    <link href="https://apelisun.github.io/2022/08/08/sql%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E2%80%98/"/>
    <id>https://apelisun.github.io/2022/08/08/sql%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E2%80%98/</id>
    <published>2022-08-08T00:30:09.000Z</published>
    <updated>2022-08-10T03:51:58.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL查询练习"><a href="#SQL查询练习" class="headerlink" title="SQL查询练习"></a>SQL查询练习</h1><blockquote><ol><li><p><strong>查询id=1课程比id=2课程成绩高的学生的信息[学生id和学生的姓名]及课程分数</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid join sc sc2 on sc1.sid=sc2.sid where sc1.cid=1 and sc2.cid=2 and sc1.score &gt;sc2.score; </span><br></pre></td></tr></tbody></table></figure></li><li><p>查询同时存在1 课程和2课程的情况</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid join sc sc2 on sc1.sid=sc2.sid where  sc2.cid =2 and sc1.cid=1 ;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询存在1 课程但可能不存在2课程的情况</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid  where  sc1.cid=1 ;</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>查询不存在1课程但存在2课程的情况</strong> (<strong>不存在时显示为 null</strong>)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sc2.sid ,sc2.cid ,sc1.score 课程1,sc2.score 课程2 from (select *from sc where cid=1 ) sc1  RIGHT join (select *from sc where cid=2 ) sc2 on sc1.sid=sc2.sid where sc1.cid is null and sc2.cid=2;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,avg(sc.score) from student s join sc sc on s.id=sc.sid group by s.id having avg(sc.score)&gt;60 ; </span><br></pre></td></tr></tbody></table></figure></li><li><p>查询在 SC 表存在成绩的学生信息</p></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.id,s.sname from student s join sc sc on s.id=sc.sid where exists(select 1 from sc where score is not null);</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li><p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id ,s.sname,count(sc.cid),sum(sc.score) from student s join sc sc where sc.sid=s.id group by s.id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询「李」姓老师的<strong>数量</strong></p><p><code>查询李老师的带过的学生的数量/授课的数量</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法一.select (select count( c.id) '授课数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id  where t.tname like '李%') 授课数,(select count( sc.sid) '学生数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id  where t.tname like '李%')  带过的学生;select (select count(distinct c.id) '授课数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id  where t.tname like '李%') 授课数；</span><br><span class="line"></span><br><span class="line">方法2. select t.tname 老师姓名, count(distinct s.id) 学生数量,count(sc.cid) 授课数量 from student s join sc sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid where t.tname like '李%' group by t.id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询学过「张三」老师授课的<strong>同学的信息</strong></p></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一.select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid=</span><br><span class="line">(select  c.id from teacher t left join  course c on c.tid=t.id where t.tname='张三')</span><br><span class="line"></span><br><span class="line"> 方法二.select  distinct s.*  from student s join sc sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid where t.tname='张三' ;</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>查询没有学全所有课程的<strong>同学的信息</strong></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname from student s join sc sc on sc.sid=s.id  GROUP BY s.id HAVING count(*)!=(select count(*) from course);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="11"><li><strong>查询至少有一门课与学号为1的同学所学相同的同学的信息</strong></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid in (select sc1.cid from sc sc1 where sc1.sid=1);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="12"><li>查询和id=1的同学学习的课程 完全相同的其他<strong>同学的信息（重要）</strong> - <em><strong>非常重要,非常重要,非常重要,非常重要,非常重要!</strong></em></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,s.age,s.sex from student s where s.id in(select sc.sid from sc where sc.sid&lt;&gt;1 and sc.cid in(select sc.cid from sc where sc.sid=1) group by sc.sid having count(*)=(select count(*) from sc where sc.sid=1));</span><br></pre></td></tr></tbody></table></figure><ol start="13"><li><p>查询没学过”张三”老师讲授的任一门课程的<strong>学生姓名</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.id ID ,s.sname 学生姓名 from sc sc2  right join student s on s.id= sc2.sid where s.id not in(select sc.sid from sc where sc.cid=(  select  c.id from teacher t left join  course c on c.tid=t.id where t.tname='张三'));</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询两门及其以上不及格课程的同学的<strong>学号，姓名及其平均成绩</strong></p></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.sname 姓名,s.id 学号,avg(sc.score) 平均分 from student  s left join sc sc on s.id=sc.sid where sc.score&lt;60 group by s.id having count(*)&gt;=2 ;</span><br></pre></td></tr></tbody></table></figure><ol start="15"><li>检索” 01 “课程分数小于 60，按分数降序排列的<strong>学生信息</strong></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.sname 姓名,s.id 学号,sc.score  from student  s left join sc sc on s.id=sc.sid where sc.score&lt;60  and sc.cid='01' order by  3 desc;</span><br></pre></td></tr></tbody></table></figure><ol start="16"><li><p>按平均成绩从高到低显示所有学生的所有课程的<strong>成绩以及平均成绩</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id ID,s.sname 姓名,coalesce(sc.cid,'未选') 课程编号, coalesce(sc.score,0) 分数,coalesce((select avg(sc2.score) from sc sc2 where sc2.sid=s.id),0) 平均分 from student  s left join sc sc on s.id=sc.sid order by 5 desc; </span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>查询各科成绩前三名的记录</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  s.id id,s.sname 姓名,sc.cid 课程号, sc.score 分数 from student  s  join sc sc on s.id=sc.sid where exists (select 1 from sc sc1 where sc.cid=sc1.cid and sc.score&lt;sc1.score  having count(*)&lt;3) order by 4 desc, 3 desc; </span><br></pre></td></tr></tbody></table></figure></li><li><p>查询每门课程被选修的学生数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select c.id 课程号,c.cname 课程名,count(sc.sid) 学生数 from sc  right join course c on c.id=sc.cid group by sc.cid;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询出只选修两门课程的学生学号和姓名</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname from student s join sc sc on sc.sid=s.id group by s.id having count(sc.cid)=2;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询男生、女生人数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.sex 性别,count(s.sex) 人数 from student s group by s.sex;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询名字中含有「风」字的学生信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student s where s.sname like '%风%';</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询<strong>同名同性</strong>学生名单，并统计同名同性人数</p></li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student s where exists (select 1 from student s2 where s2.sname=s.sname having count(*)&gt;=2);</span><br></pre></td></tr></tbody></table></figure><ol start="23"><li>查询 1990 年出生的学生名单</li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from student s where year(s.age)=1990; </span><br></pre></td></tr></tbody></table></figure><ol start="24"><li><p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select c.cname 课程名,sc.cid 课程id,avg(sc.score) 平均成绩 from course c left join sc sc on sc.cid=c.id group by c.id order by  3 desc,2;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩</p></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id id,s.sname 姓名,coalesce(avg(sc.score),0) 平均成绩 from student s left join sc sc on s.id=sc.sid group by s.id having 平均成绩&gt;85;</span><br></pre></td></tr></tbody></table></figure><ol start="26"><li><p>查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id id,s.sname 姓名,sc.score 分数 from student s join sc sc on s.id=sc.sid join course c on c.id=sc.cid where c.cname='数学' and sc.score&lt;60;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id id,s.sname 姓名 ,sc.cid 课程名 ,sc.score 分数 from student s left join sc sc on s.id=sc.sid where sc.score&gt;70;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询存在不及格的课程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sc.cid ,c.cname from sc sc join course c on c.id=sc.cid where sc.score&lt;60 group by sc.cid ;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid=1 and sc.score&gt;80 group by s.id,s.sname;</span><br></pre></td></tr></tbody></table></figure></li><li><p>求每门课程的学生人数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sc.cid ,count(sc.sid) from sc group by sc.cid ;</span><br></pre></td></tr></tbody></table></figure></li><li><p>假设<strong>成绩不重复</strong>，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,sc.score from student s join sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid and t.tname ='张三' where exists (select * from sc sc2 where sc.cid=sc2.cid and sc.score&lt;sc2.score having count(*)&lt;1) ;</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>假设成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</strong></p></li></ol>   <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student s join sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid and t.tname ='张三' where exists (select * from sc sc2 where sc.cid=sc2.cid and sc.score&gt;=sc2.score having count(*)=(select count(sc3.cid) from sc sc3 where sc3.cid=sc.cid)) ;</span><br></pre></td></tr></tbody></table></figure><ol start="33"><li><p>查询<strong>不同课程成绩相同</strong>的学生的学生编号、课程编号、学生成绩</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s.id,s.sname,sc.cid,sc.score from student s join sc sc on sc.sid=s.id join sc sc2 on sc.sid=sc2.sid where sc.score=sc2.score and</span><br><span class="line">sc.cid!=sc2.cid;</span><br></pre></td></tr></tbody></table></figure></li><li><p>统计每门课程的学生选修人数（超过 5 人的课程才统计）</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sc.cid,count(*) from sc group by sc.cid having count(*)&gt;5</span><br></pre></td></tr></tbody></table></figure><ol start="34"><li>检索至少选修两门课程的学生学号</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id from student s join sc on sc.sid=s.id  group by s.id having count(sc.cid)&gt;=2;</span><br></pre></td></tr></tbody></table></figure><ol start="36"><li>查询选修了全部课程的学生信息</li></ol>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id from student s join sc on sc.sid=s.id  group by s.id having count(sc.cid)=(select count(c.id) from course c );  </span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL查询练习&quot;&gt;&lt;a href=&quot;#SQL查询练习&quot; class=&quot;headerlink&quot; title=&quot;SQL查询练习&quot;&gt;&lt;/a&gt;SQL查询练习&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查询id=1课程比id=2课程成绩高的学</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://apelisun.github.io/tags/mysql/"/>
    
    <category term="interview" scheme="https://apelisun.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
