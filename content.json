{"meta":{"title":"ape_li","subtitle":"","description":"","author":"ape_li","url":"https://apelisun.github.io","root":"/"},"pages":[{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2022-08-10T09:27:17.597Z","comments":true,"path":"PY.html","permalink":"https://apelisun.github.io/PY.html","excerpt":"","text":""}],"posts":[{"title":"储存函数触发器","slug":"储存函数触发器","date":"2022-08-09T13:24:55.000Z","updated":"2022-08-10T03:52:49.694Z","comments":true,"path":"2022/08/09/储存函数触发器/","link":"","permalink":"https://apelisun.github.io/2022/08/09/%E5%82%A8%E5%AD%98%E5%87%BD%E6%95%B0%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"#函数function mysql中内置了很多函数 mysql8.0不支持创建函数的语法的 解决方案: 在my.ini或者my.cnf文件下添加： [mysqld] log-bin-trust-function-creators=1 最后mysql服务器重启 创建语法 函数体中一定有return语句 只要遇到varchar类型,必须要指定参数的长度 语法部分 12345678910-- 重新定制mysql的结束符号,sql语句的结束符号默认的是分号delimiter $$ create function 函数名([变量名 数据类型(长度)]) returns 返回类型begin -- -- 函数体 return 结果;end $$ delimiter ; 练习 传入俩个整数,返回俩个整数的相加的结果 123456789delimiter //create function dy_add(a int,b int) returns intbegin return a + b;end //delimiter ;-- 调用函数select dy_add(50,10); 练习 写一个函数可以实现日期转成指定格式的字符串xxxx年xx月xx日 123456789101112date_format(date,pattern)drop function dy_format;delimiter //create function dy_format(dt date) returns varchar(20)begin return date_format(dt,'%Y年%m月%d日');end //delimiter ;select dy_format(now()); 语句语法 while..do..end while 求出1~x之间的总和 12345678910111213141516171819drop function x_add;delimiter //create function x_add(x int) returns intbegin -- 循环变量因子,局部变量 declare i int default 1; -- 定义一个变量,用来保存总的和 declare sums int default 0; while i&lt;=x do -- 对已经声明过的变量进行赋值操作 set sums = sums + i; set i = i + 1; end while; return sums;end //delimiter ;select x_add(100); 分支语句if … then…end if 12345678910111213141516 -- 求出1~x之间奇数的总和drop function ji_add; delimiter //create function ji_add(x int) returns intbegin declare i int default 1; declare sums int default 0; while i&lt;=x do if i%2!=0 then set sums = sums+i; end if; set i = i + 1; end while; return sums;end //delimiter ; 1select ji_add(100); 全局变量 求出1~x之间的数字之和,但是不包括5的倍数 1234567891011121314151617181920212223242526drop function my_add;delimiter //create function my_add(x int) returns intbegin -- 定义一个局部变量 declare i int default 1; -- 定义一个全局变量,用来存储总和 -- 全局变量 @变量名 -- 系统的全局变量 @@tx_isolation set @sums = 0; -- 对语句片段进行一个命名 - 类似于java中的continue语句 -- 命名是任意的 success:while i&lt;=x do -- mysql中判断是否相等,= if i%5=0 then set i = i + 1; -- continue - 跳过本轮循环,继续下一轮循环 iterate success; end if; set @sums = @sums + i; set i = i + 1; end while; return @sums;end //delimiter ; 1234select my_add(100);-- 全局变量,在函数体外调用select @sums; 存储过程 定义:为了完成一些特定的工程,提前将sql语句预编译好,存储在在mysql-server端.并且只会编译一次.后面直接调用 存储过程的时候,是不需要再次对sql语句进行编译了,提高性能. 存储过程可以做到标准的组件编程[把sql封装好,形成一个组件] sql执行的过程 mysql-client 客户端编写sql语句 mysql&gt; select * from s_emp; 将这个客户端的sql发送到mysql-server端,需要对这条sql进行编译[检测语法]以及解析. mysql-server将解析之后的结果返回给mysql-client; 在没有使用存储过程之前,只要将sql语句发送到mysql-server端,每次都是需要对sql进行编译的.比较浪费时间. 语法12345678910-- 删除存储过程drop procedure 存储过程名;-- 创建存储过程delimiter //create procedure 存储过程名([in|out] 变量名 数据类型)begin -- 过程体end //delimiter ; 体验123456789-- 把s_emp表中的员工的平均薪资预编译好在mysql-server端存储delimiter //create procedure pro_sal()begin select avg(salary) from s_emp;end //delimiter ;call pro_sal(); in - 接受参数123456789101112drop procedure in_pro;delimiter //create procedure in_pro(in a int)begin -- 输出System.out.println(a) -- 变量a是否有输出 select a; -- set @i = 900,但是in来修饰的 set a = 900;end //delimiter ; 1234567-- 直接接受一个字面量call in_pro(10);-- 接受一个全局变量set @a=10;call in_pro(@a);-- 10select @a; out - 返回结果123456789101112drop procedure out_pro;delimiter //create procedure out_pro(out a int)begin -- 输出System.out.println(a) -- out修饰的 - 不能够接受外面传进来的参数 select a; -- 给a重新赋值 - set @i = 800 set a = 800;end //delimiter ; 1234567891011121314151617181920-- 注意点:如果参数使用out,那么此处是不允许直接使用字面量进行传参call out_pro(100);ERROR 1414 (42000): OUT or INOUT argument 1 for routine dy.out_pro is not a variable or NEW pseudo-variable in BEFORE trigger-- 只能使用全局变量进行传参set @i = 100;call out_pro(@i);-- 发现a为null+------+| a |+------+| NULL |+------+select @i;+------+| @i |+------+| 800 |+------+ 练习 - 封装单个结果集方式一 根据员工的id来返回员工的名称,薪资 和表结合一起使用的话,数据类型和表统一 123456789101112drop procedure find_pro;delimiter //create procedure find_pro(in eid int(7),out fname varchar(20),out sal float(11,2))begin select first_name into fname from s_emp where id=eid; select salary into sal from s_emp where id=eid;end //delimiter ;call find_pro(1,@fname,@sal);select @fname;select @sal; 方式二 统一赋值 1234567891011drop procedure find_pro;delimiter //create procedure find_pro(in eid int(7),out fname varchar(20),out sal float(11,2))begin select first_name,salary into fname,sal from s_emp where id=eid;end //delimiter ;call find_pro(1,@fname,@sal);select @fname;select @sal; 练习 - 封装多个结果集 传统的做法 - 已经被弃用了 - 性能比较低 - 游标 定义第三张表来存储多个结果集 12345678910111213-- 构建临时表 - 结果集create table emp_copy as select first_name,salary from s_emp where 1=2;drop procedure find_pro;delimiter //create procedure find_pro(in eid int(7))begin insert into emp_copy(first_name,salary) select first_name,salary from s_emp where id&gt;eid;end //delimiter ;call find_pro(20);select * from emp_copy; 练习 - 带事务 转账功能 - 要么同时成功,要么同时失败 12345678910111213141516171819202122232425262728drop procedure transfer_pro;delimiter //create procedure transfer_pro(in sid int(7),in tid int(7),in money double(10,2),in st int(7))begin -- 定义一个局部变量,用来展示是否转账成功 declare msg varchar(20) default '';-- 手动开启失败start transaction;-- 第一条sqlupdate t_acc set balance = balance - money where id = sid;-- 故意搞事情if st=1 then set msg = 'sorry,转账失败!'; -- 事务回滚 rollback;else -- 第二条sql update t_acc set balance = balance + money where id = tid; set msg = 'good,转账成功!'; -- 手动提交事务 commit;end if;select msg;end //delimiter ; 12345-- 转账成功call transfer_pro(1,2,1000,2);-- 转账失败call transfer_pro(1,2,1000,1); 语句使用条件分支语句 if 条件表达式 then elseif … then … else…end if; 1234567891011121314151617drop procedure if_pro;delimiter //create procedure if_pro(in a int)begin declare msg varchar(20) default ''; if a&gt;=90 then set msg = '优秀'; elseif a&gt;=80 then set msg = '良好'; elseif a&gt;=60 then set msg = '中等'; else set msg='不及格'; end if; select msg;end //delimiter ; 1call if_pro(85); case .. when 固定的值 then .. else .. end case 12345678910111213141516drop procedure case_pro;delimiter //create procedure case_pro(in a int)begin declare msg varchar(20) default ''; case a when 1 then set msg = '1'; when 2 then set msg = '2'; else set msg = '3'; end case; select msg;end //delimiter ; 1call case_pro(2); 循环语句 while … do .. end while 1234567891011121314151617181920drop procedure while_pro;delimiter //create procedure while_pro(in x int,out result int) begin -- 定义一个局部变量 int i = 1 declare i int default 1; -- 保存最终的总和 declare sums int default 0; -- 循环 while i&lt;=x do -- sums自增1 set sums = sums + i; -- i应该要自增1 set i = i + 1; end while; -- select sums; set result = sums;end //delimiter ; 12call while_pro(100,@result);select @result; loop .. end loop - 类似于java中的while(true) 12345678910111213141516171819202122-- 1~xdrop procedure loop_pro;delimiter //create procedure loop_pro(in x int)begin declare i int default 1; declare sums int default 0; success:loop if i&gt;x then -- 打破循环的语句 -- iterate success; 类似于continue -- 类似于break leave success; end if; set sums = sums + i; set i = i + 1; end loop; select sums;end //delimiter ; 1call loop_pro(100); repeat … until … end repeat 12345678910111213drop procedure repeat_pro;delimiter //create procedure repeat_pro(in x int)begin -- 但是先进入到这个循环体中先执行一遍,然后再进行判断 repeat set x = x + 1; select x; -- 如果x&gt;0,循环停止了 until x&gt;0 end repeat;end //delimiter ; 1call repeat_pro(1); 存储过程和函数的区别 定义函数的时候,在函数的签名上必须要指定returns返回类型,定义存储过程的时候不需要使用returns来指定返回类型 函数体中必须要有return语句来返回函数的执行结果,但是存储过程中可以没有return语句 调用函数使用select,调用存储过程使用call 存储过程更加侧重于sql的封装以及sql的预编译,提高效率和安全和sql的复用性 存储过程必须要使用in来接受参数,使用out来返回结果 触发器在myql中,当我们执行一些操作的时候,比如DML操作(触发器触发的事件),一旦事件被触发,那么 就会执行一段程序.触发器本质上就是一个特殊的存储过程. 分类 after触发器 - 在触发条件之后执行 before触发器 - 在触发条件之前执行 语法123456789101112-- 删除触发器drop trigger 触发器名称;delimiter $$-- 创建触发器create trigger 触发器名触发时机(after,before) 触发事件(insert,delete,update) on 触发器事件所在的表名for each row-- 触发器需要执行的逻辑.beginend$$delimiter ; 练习1create table t_acc_copy as select * from t_acc where 1=2; 删除t_acc表中的任意一条数据之后,会在t_acc_copy表中插入一条. 123456789drop trigger acc_tri;delimiter //create trigger acc_triafter delete on t_accfor each rowbegin insert into t_acc_copy values(old.id,old.balance);end //delimiter ; 12345678910mysql&gt; delete from t_acc where id=1;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t_acc_copy;+------+---------+| id | balance |+------+---------+| 1 | 1000.00 |+------+---------+1 row in set (0.00 sec) 级联删除 - 删除t_customer中的客户信息之前需要级联删除该客户的订单信息 1234567891011drop trigger acc_tri;delimiter //create trigger cus_tribefore delete on t_customerfor each rowbegin delete from t_ord where customer_id=old.id;end //delimiter ;delete from t_customer where id=2; oracle中支持自检约束check 123456789101112131415161718drop table cks;create table cks( id int(7) primary key auto_increment, age int(7));insert into cks values(1,30);insert into cks values(2,30);auto_increment 主键自增长的策略,默认值是从1开始,步长为1. 主键列不需要设置值insert into cks(age) values(20);insert into cks(age) values(30);delete from cks where id=2;insert into cks(age) values(40);select * from cks;-- auto_increment - 主键列数据类型不能是varchar-- auto_increment到达最大值 mysql用触发器来实现自检约束 1234567891011121314-- 插入age只能在(0,18]区间,否则报错.drop trigger cks_tri;delimiter //create trigger cks_tribefore insert on cksfor each rowbegin if new.age&lt;0 or new.age&gt;18 then signal sqlstate '42000' set message_text='age必须在0~18区间'; end if;end //delimiter ;insert into cks(age) values(200);","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"procedure","slug":"procedure","permalink":"https://apelisun.github.io/tags/procedure/"}]},{"title":"B+树","slug":"B+树","date":"2022-08-09T13:24:28.000Z","updated":"2022-08-10T09:46:50.985Z","comments":true,"path":"2022/08/09/B+树/","link":"","permalink":"https://apelisun.github.io/2022/08/09/B+%E6%A0%91/","excerpt":"","text":"索引底层原理 解释底层的索引的数据结构 - b+树 B+树 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树， 平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。 索引文件和数据文件 - innodb中 - 合二为一的 - 只有1个文件 索引文件和数据文件 - myisam中 - 分开独立的 - 俩个文件 二叉树 节点(每个圆圈圈)中存储了键（key - 主键索引列）和数据（data - 每一个行记录）。键对应 user 表中的 id，数据对应 user 表中的行数据。 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： id=12先和根节点[只有一个]key=10,发现id=12&gt;id=10 - 顺利向着根节点的右边去匹配 id=12和非叶节点id=13的进行匹配,顺利执行id=13的左边 id=12和id=12比较 - 两者是相同的.由于每个节点除了保存key还保存了value[行记录 - 行真实的行数据] 直接将这个节点的value直接取出来了. 总结 - 总共匹配了3次就可以顺利找到我们的数据. 如果没有创建二叉树索引.查找id=12,必然会进行全表扫描.从表的第一行向下找.最好的状态也得找6次 平衡二叉树二叉树带来的弊端 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值 二叉树在极端的场景下有可能成为一个链表的结构[链表的查询效率很低很低的.] 查找id=12,”链表结构”,只能从链表的头节点开始查找,最佳状态也得寻找找了5次. AVL为了解决这个问题[防止二叉树变成了链表结构导致查询效率依然低下]，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树. 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 下面是平衡二叉树和非平衡二叉树的对比： 只要找到任何一个节点的左右子树高度差的绝对值大于1 - 非平衡二叉树 123节点45 - 左子树高度 = 左边的子节点的个数 = 2 - 右子树高度 = 右边没有节点 = 0 - |高度差|=2&gt;1 B树 平衡二叉树暴露出来了一些缺点: 每个节点仅仅保存一个key-value键值对[每个节点可保存的键值对数据太少了].每次进行查询的时候,实际上都是需要从磁盘中读取数据的. 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块 由于每个节点可保存的数据不多,仅仅保存了一个key-value.在查找数据的过程中,它就不断去和磁盘进行IO交互. 导致平衡二叉树的节点比较多.也就导致了平衡二叉树的高度比较高 - 导致比较的次数比较多 - 频繁和IO进行交互 - 查询效率低下. 为了解决平衡二叉树的高度太高问题.B树登场了. B树特点 根节点[第一页] - 永驻内存. 每个节点可以保存多个key-value - 导致子节点也会增多.B树又矮又胖. 没有子节点的节点 - 叶节点,有子节点的节点 - 非叶节点 B树的m阶 - m值就是看它最大的子节点的个数 - 3 , 下面的图代表的就是3阶b树. 如果有10亿条数据,只需要和磁盘进行交互2次.把磁盘块中的一页数据[16kb]全部加载到内存中. 页page的概念 - 那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块 读取的单位是 - 页 - 1页的磁盘块的数据大小是16kb,每个节点可以更多的key-value 页与也之间是一个链表的结构 查找id=28的数据 - 磁盘交互了3次 ①id=28到第一页中进行匹配,发现id=28在17和35之间,获取p2指针.p2指向到页3 ②定位到页3,发现id=28在26~30之间,继续拿到p2指针,p2指向的是页8 ③定位到页8,顺利匹配查找到id=28这条数据 B+树 是Innodb和myisam存储引擎中索引底层的数据结构 - B+树 B树中每个节点中不仅仅存储key[索引列值,主键列值],还存储了数据.因为数据库中的页的大小是固定的[Innodb默认是16kb], 导致每个节点的存储资源有点浪费了. B+树和B树的重要区别就是 B+树中非叶节点,仅仅保存了key值[索引列,主键列值],没有保存数据.每个非叶节点可以保存更多的key B+树中索引的所有的数据都放在了叶子节点中,而且是按照顺序排列的. **页与页之间是双向链表结构,**叶节点中的每个数据节点单向链表 下面这个图展示的是Innodb中的索引的结构.并不是Myisam中索引的结构 以下图示本质上就是聚簇索引[主键列索引]的方式 - key - 主键列 聚簇索引和非聚簇索引在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。 那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引： 聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。 这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。 这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。 非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 聚簇索引存储和查找 先到非叶节点找到索引列所在的页位置 根据页位置定位到叶节点的位置 叶节点中根据索引列的值找出数据 12345select * from xx where id&gt;=18 and id&lt;41;-- 聚簇索引的查找方式 - 根据主键列id列进行查找的流程1. 先从页1中看id的区间,定位到p2-&gt;页32. 定位到页3,定位到p1-&gt;页8[叶节点-单向链表 - 查找必须从头节点开始找]3. 依次按照链表的顺序一致找到id开始&lt;41的这个节点.满足条件的叶节点中的数据全部查出来 [叶节点中保存了真实的数据] 非聚簇索引存储和查找 B+树的结构 表结构:id age name id - 主键列 - 默认是聚簇索引列 - 主键列 name - 非聚簇索引列 - 索引列 - 辅助索引 非聚簇索引 - 非主键列索引 - name列创建了索引 - 辅助索引. 结构: 根节点 - 一页数据 - 非聚簇索引列值 - name 非叶节点 - 非聚簇索引列值 页节点存储的东西 - name索引列以及该列对应的主键列值. - 这是和聚簇索引最大的一个不同点 它和聚簇索引最大的区别是页节点中没有存储最终的数据.而是存储的是键值对x-y x就是非聚簇索引列值,y是对应的主键列值. 非聚簇索引的查找方式: 1select * from xxx where name='Bob'; 按照B+树的查找流程 - 确认name=’Bob’的具体位置 由于非聚簇索引的结构中叶节点仅仅保存了name-主键列值 先根据name=’Bob’这个条件找到对应的主键列值id=15 要进行”回表操作” 继续拿着主键列id=15到索引的结构中继续查找一次 - “一次回表查找”. id也是聚簇索引 - B+树的结构 - 叶子节点中存储的就是数据. 根据聚簇索引列的查找方式 - id=15的叶节点 - 拿到里面的数据 非聚簇索引列查找一定会回表????? 未必 - 因为非叶节点中存储的就是索引列值. 查询 select id from xxx where name=’Bob’;select name from xxx where name=’Bob’; 不需要回表了.这条语句查询的结果name已经在非聚簇索引的非叶节点中保存了. 回表 根据一个非聚簇索引列查找 - 优先先到非聚簇索引的B+树中找到该列对应的主键列值[聚簇索引列值] 再拿着这个聚簇索引列的值再去到聚簇索引列的B+树中再查找一次 myisam中的索引特点 索引的本质就是一个键值对key-value key - 索引列值,value - 数据行的物理地址. 主键列索引/辅助索引 -&gt; 两颗独立的B+树,都是索引列值对应的行记录的物理地址. innodb中索引和数据合并到一个文件中 myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件. myisam中采用的是”非聚集的方式” 无论是聚簇索引还是非聚簇索引,查找方式是一样. 采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.** 需要再根据行记录地址到表中进行定位[回表] 123456主键列 - key是不允许重复的非主键列 - key是允许重复的.select * from xxx where id=5;1. 先到B+树找到找到id=5对应的节点 - 取出里面的行记录的物理地址0x6a2. 回表 - 直接根据行记录的物理地址直接定位到具体的一行.","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"B+树","slug":"B-树","permalink":"https://apelisun.github.io/tags/B-%E6%A0%91/"}]},{"title":"sql习题1","slug":"sql习题1","date":"2022-08-09T13:23:45.000Z","updated":"2022-08-10T03:52:13.995Z","comments":true,"path":"2022/08/09/sql习题1/","link":"","permalink":"https://apelisun.github.io/2022/08/09/sql%E4%B9%A0%E9%A2%981/","excerpt":"","text":"现有一个商店的数据库，记录顾客及其购物情况，由下面三个表组成： 商品product（商品号productid int(7)]，商品名productname [varchar(128)]， 单价unitprice int(11,2)， 商品类别category[varchar(28)]， 供应商provider [varchar(48)]）； 主键：productid 顾客customer（顾客号customerid int(7)]，姓名name[varchar(48)]， 住址location[varchar(128)]）； 主键：customerid 购买purcase（顾客号customerid，商品号productid，购买数量quantity[int(7)]）； 外键：customerid 引用 客户表的 customerid 外键：productid 引用 产品表的 productid 主键：(customerid, productid) –&gt; 联合主键 任务一:使用DDL语言创建上面的表,并且设置必要的主键约束和外键约束 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455drop table product;create table product(productid int(7) primary key,productname varchar(128),unitprice double(11,2),catagory varchar(28),provider varchar(48));drop table customer;create table customer(customerid int(7) primary key,name varchar(48),location varchar(128));drop table purcase;create table purcase(customerid int(7),productid int(7),quantity int(7),constraint purcase_id_pk primary key(customerid,productid),constraint purcase_id1_fk foreign key(productid) references product(productid),constraint purcase_id2_fk foreign key(customerid) references customer(customerid) );insert into product values(1,'佳洁士',8.00,'牙膏','宝洁'),(2,'高露洁',6.50,'牙膏','高露洁'),(3,'洁诺',5.00,'牙膏','联合利华'),(4,'舒肤佳',3.00,'香皂','宝洁'),(5,'夏士莲',5.00,'香皂','联合利华'),(6,'雕牌',2.50,'洗衣粉','纳爱斯'),(7,'中华',3.50,'牙膏','联合利华'),(8,'汰渍',3.00,'洗衣粉','宝洁'),(9,'碧浪',4.00,'洗衣粉','宝洁');insert into customer values(1,'Dennis','黄浦区'),(2,'John','徐家汇'),(3,'Tom','闸北'),(4,'Jenny','静安'),(5,'Rick','浦东');insert into purcase values(1,1,3), (1,5,2),(1,8,2) , (2,2,5),(2,6,4) , (3,1,1),(3,5,1 ), (3,6,3),(3,8,1 ), (4,3,7),(4,4,3 ), (5,6,2),(5,7,8); 任务二: 向对应的表中插入如下数据 123456789101112131415161718192021222324252627商品（1，佳洁士，8.00，牙膏，宝洁； 2，高露洁，6.50，牙膏，高露洁； 3，洁诺，5.00，牙膏，联合利华； 4，舒肤佳，3.00，香皂，宝洁； 5，夏士莲，5.00，香皂，联合利华； 6，雕牌，2.50，洗衣粉，纳爱斯 7，中华，3.50，牙膏，联合利华； 8，汰渍，3.00，洗衣粉，宝洁； 9，碧浪，4.00，洗衣粉，宝洁；）顾客（1，Dennis，黄浦区； 2，John，徐家汇； 3，Tom，闸北； 4，Jenny，静安； 5，Rick，浦东；） 购买(1，1，3； 1，5，2； 1，8，2； 2，2，5； 2，6，4； 3，1，1； 3，5，1； 3，6，3； 3，8，1； 4，3，7； 4，4，3； 5，6，2； 5，7，8；） 任务三: 完成如下语句 123456789101112131415161718192021222324252627282930（1）求购买了供应商\"宝洁\"产品的所有顾客；select distinct c.customerid,c.name from customer c join purcase p on p.customerid=c.customerid where p.productid in (select pr.productid from product pr where pr.provider='宝洁');+------------+--------+| customerid | name |+------------+--------+| 1 | Dennis || 3 | Tom || 4 | Jenny |+------------+--------+（2）求购买的商品包含了顾客\"Dennis\"所购买的所有商品的顾客（姓名）select p2.customerid from purcase p2 where p2.productid in (select p.productid from customer c join purcase p on c.customerid=p.customerid where c.name='Dennis') and customerid&lt;&gt;(select distinct p4.customerid from customer c4 join purcase p4 on p4.customerid=c4.customerid where c4.name=\"Dennis\") group by p2.customerid having count(*)&gt;=(select count(*) from customer c2 join purcase p3 on c2.customerid=p3.customerid where c2.name='Dennis');+------------+| customerid |+------------+| 3 |+------------+（3）求牙膏卖出数量最多的供应商。select pr.provider,sum(pu1.quantity) from product pr join purcase pu1 on pu1.productid=pr.productid and pr.catagory='牙膏' GROUP BY pr.provider order by sum(pu1.quantity) desc limit 1;+--------------+-------------------+| provider | sum(pu1.quantity) |+--------------+-------------------+| 联合利华 | 15 |+--------------+-------------------+(4)将所有的牙膏商品单价增加10%。update product set unitprice=unitprice*1.1 where catagory='牙膏';(5)删除从未被购买的商品记录。delete from product where productid not in (select pu.productid from purcase pu);","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"homework","slug":"homework","permalink":"https://apelisun.github.io/tags/homework/"}]},{"title":"mysql3","slug":"mysql3","date":"2022-08-09T13:23:13.000Z","updated":"2022-08-10T03:49:53.353Z","comments":true,"path":"2022/08/09/mysql3/","link":"","permalink":"https://apelisun.github.io/2022/08/09/mysql3/","excerpt":"","text":"DB设计 指导db设计的思想,避免表中出现大量的冗余的数据.但是实际开发中表中是允许出现冗余的字段的. 冗余数据的好处 - 安全,方便查询.坏处-&gt;delete和update操作 1NF - 第一范式-保证列的原子性,保证列不可再切割 s_emp(id,name) - 发现name不具备原子性,可以被再次切割(fist_name,last_name) s_ord(id,address) - address显示为省市区 - 江苏省苏州市园区 address再次分成(province,city,area) 12345678主要是为了查询.select * from s_ord where address like '%苏州%';select * from s_ord where city = '苏州';-- address,city加索引.-- 模糊查询可能导致索引失效.但是精确匹配是走索引的. 2NF - 基于1NF,要求非关键列要全部依赖于关键列. 不存在非关键列部分依赖于关键列 关键列 - 主键列 - 非空且唯一 - table中的id设置成主键列. student(sid,sname,cid,cname);//关键列(sid,cid) - 确定唯一的元组(行) - 复合主键 sname,cname - 非关键列. (sid,cid) -&gt; 唯一确定 -&gt; sname/cname sid -&gt; sname,cid -&gt; cname 123student(sid,sname)course(cid,cname);sc(sid,cid,kpi);//(sid,cid) -&gt; kpi 3NF- 基于2NF,要求非关键列不能传递依赖于关键列. student(sid,sname,uid,uv_name,u_phone); u_phone传递依赖于sid - 原因sid -&gt; uid -&gt; u_phone 12student(sid,sname,uid);//uid就是foreign key 外键列university(uid,u_name,u_phone); 练习 用户表t_user 视频表t_video 评论表和回复表设计 用户对视频进行评论(t_comment)和回复(t_repy)的场景: tom 发布了 搞笑的视频 admin 评论: 😁😎 ​ li评论admin: 你笑什么! ​ lei回复@li: 管你什么事情! ​ x回复@li: 你想表达什么! ​ y回复@x: …. ​ k 评论admin:你笑什么! jack 评论: 😄 t_user id usernmae 1 tom 2 admin 3 li 4 lei 5 x 6 y 7 k t_video 一个用户可以发布多个视频 id video user_id 1 佩洛西 1 t_comment id video_id content comment_id user_id 1 1 😁😎 2 2 1 你笑什么! 1 3 3 1 你笑什么! 1 7 t_reply id comment_id conent reply_id user_id 1 2 管你什么事情! 4 2 2 你想表达什么! 5 3 2 … 2 6 DDL语言 Data Definition Language - 数据定义语言. 包括的命令:create drop alter comment rename truncate 数据类型 数字类型 整数 - int/bigint 小数 - float/double/decimal 要点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455drop table t_type;create table t_type( id int(7));此处的7并不是代表此列的最大长度.误区:最大可保存的值是9999999实际上该列可以存储的最大值是由类型决定了.配置zerofill 0填充create table t_type( id int(7) zerofill);insert into t_type values(1);不足7位,会采用0来填充+---------+| id |+---------+| 0000001 |+---------+drop table t_type;create table t_type( c1 float(5,2), c2 double(5,2), c3 decimal(5,2));float(m,n) =&gt; m总长度,n代表的小数点insert into t_type(c1) values(12.345);mysql&gt; select * from t_type;-- 小数保留2位,并且四舍五入+-------+------+------+| c1 | c2 | c3 |+-------+------+------+| 12.35 | NULL | NULL |+-------+------+------+mysql&gt; insert into t_type(c2) values(123.5); //okmysql&gt; select * from t_type;+-------+--------+------+| c1 | c2 | c3 |+-------+--------+------+| 12.35 | NULL | NULL || NULL | 123.50 | NULL |+-------+--------+------+mysql&gt; insert into t_type(c2) values(1234.5);`原因:1234.5 =&gt; 1234.50 已经超过5位了`ERROR 1264 (22003): Out of range value for column 'c2' at row 1float/double =&gt; 非标准 decimal标准 - 对精度有特别要求的insert into t_type(c3) values(123.589); 关于日期类型 date datetime 12345678910111213141516171819202122drop table t_type;create table t_type( id int, create_date date default now());ERROR 1067 (42000): Invalid default value for 'create_date'如果某个列期望默认值是now(),一定要设置成datetimedrop table t_type;create table t_type( id int, create_date datetime default now());insert into t_type(id) values(1);-- 满足日期能够支持的字符串格式drop table t_type;create table t_type( id int, create_date date default '2012-09-08 12:12:12');insert into t_type(id) values(1); 字符串类型 char和varchar区别 char(n),varchar(n) =&gt; 代表的字符的个数 区别: char是定长,varchar是可变长. 1234567891011121314151617181920212223drop table t_type;create table t_type( s1 char(2), s2 varchar(2));insert into t_type(s1) values('ab');insert into t_type(s2) values('abc');char(2) =&gt; 实际存储1个'a',实际消耗了2个varchar(2) =&gt; 假设'a',实际仅仅消耗了1个,最大消耗2个.varchar更加节约空间. char效率会更高一点 - 不推荐用char-- oracle中数据中drop table t_type;create table t_type( s1 char(2));insert into t_type(s1) values('a');-- oracle查询为empty-- mysql中空直接比较的时候剔除,大小写比较都是一样的.select * from t_type where s1='a'; text - 0-65 535 bytes - 长文本 约束类型 主键约束 primary key 非空且唯一 主键列可以是由多列共同组成 - 符合主键列 但是表中只能出现一个主键 外键约束 foreign key 外键列允许为null 外键列是多出现在多的一方中.建立表与表之间的关系的 开发中不需要设置外键 - 造成表与表之间的耦合. 表和表之间的关系是在”心中”! 非空约束 - not null 唯一约束 - unique default - 默认值 mysql中不支持自检约束,oracle中支持的check检查约束.但是mysql中可以使用触发器来实现. 创建表语法123456789101112131415161718DROP table 表名;-- 约束列级添加CREATE TABLE 表名( 列名 数据类型(n) 约束类型 COMMNET '注释', 列名 数据类型(n) 约束类型 COMMNET '注释') ENGINE=InnoDB DEFAULT CHARSET=utf8;engine 指定存储引擎,默认的就是innodb(外键约束,事务,行锁,表锁)之前的版本应该是myisam(仅仅支持表锁)-- 约束表级-- 约束命名规范:表名_列名_约束类型缩写CREATE TABLE 表名( 列名 数据类型(n) COMMNET '注释', 列名 数据类型(n) COMMNET '注释', [CONSTRAINT 约束名称] 约束类型(列名), [CONSTRAINT 约束名称] 约束类型(列名)); 列级添加方式 直接在列的后面的增加关于该列的约束 12345678drop table t_user;create table t_user( id int(7) primary key,username varchar(20) unique not null, birthday date default '1991-09-08');insert into t_user(id) values(1); 表级添加方式12345678910111213141516171819202122232425262728293031323334353637383940414243-- not null仅仅支持列级添加drop table t_user;create table t_user( id int(7), username varchar(20) not null, birthday date, constraint t_user_id_pk primary key(id), constraint t_user_username_uq unique(username));-- 约束名 - 提高错的可读性insert into t_user(id) values(1);-- 数据字典 - 描述表的表-- 数据字典就是用来存放用户信息/用户创建的这表的信息.show tables;desc 表名;-- 使用系统自带的数据库mysqluse information_schema-- TABLE_CONSTRAINTS 表名 - 数据字典 - 专门存储每个用户的表的约束信息desc table_constraints+--------------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------+--------------+------+-----+---------+-------+| CONSTRAINT_CATALOG | varchar(512) | NO | | | || CONSTRAINT_SCHEMA | varchar(64) | NO | | | || CONSTRAINT_NAME | varchar(64) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || CONSTRAINT_TYPE | varchar(64) | NO | | | |+--------------------+--------------+------+-----+---------+-------+CONSTRAINT_NAME - 约束名称TABLE_NAME - 表名CONSTRAINT_TYPE - 约束类型-- 查询出T_USER表中的约束信息select constraint_name,constraint_type,table_name from table_constraintswhere table_name='T_USER' and table_schema='dy';-- 查询t_user表中的所有的列的名称以及列的数据类型select column_name,column_type,data_type,column_key from columns where table_schema='dy' and table_name='t_user'; 建表的其他语法 利用一张已经存在的表来构建另外一张表 保留原来表中的数据 123456789101112131415drop table t_user;create table t_user( id int(7), username varchar(20) not null, birthday date, constraint t_user_id_pk primary key(id), constraint t_user_username_uq unique(username));insert into t_user values(1,'tom','2021-09-08');insert into t_user values(2,'jack','2022-09-08');-- 克隆CREATE TABLE 表名 AS SELECT查询语句;create table t_user_copy as select * from t_user; 保留原表的结构,但是不保留数据 123drop table t_user_copy; create table t_user_copy as select * from t_user where 1=2; 查看建表语句-DDL 1show create table 表名; 如果是一个1:n 123456789101112131415161718drop table t_ord;drop table t_customer;create table t_customer( id int(7), cname varchar(20) not null, constraint t_customer_id_pk primary key(id));create table t_ord( id int(7) primary key, ord_no varchar(20) not null unique, total double(7,2), customer_id int(7), constraint t_ord_customer_id_fk foreign key(customer_id) references t_customer(id));-- 一定是父级表t_customer-- 删表 - 先删除子表,多的一方,外键所在的那张表. n:n 1234567891011121314151617drop table t_sc;drop table t_student;drop table t_course; create table t_student( id int primary key);create table t_course( id int primary key);create table t_sc( sid int, cid int, primary key(sid,cid), foreign key(sid) references t_student(id), foreign key(cid) references t_course(id)); 自学的知识点 四种分区方式 - 测试 DML操作insert语句 给表中所有的列都插入数据,但是需要注意的是顺序/类型/约束 1insert into 表名 values(列1,列2,列3); 给指定的列插入数据 1insert into 表名(列名1,列名2) values(列1,列2); 批量插入 1insert into 表名 values(列1,列2,列3),(列1,列2,列3),(列1,列2,列3); delete语句 delete from 表名;//删除表中的数据 delete from 表名 where 条件; 外键约束会对delete产生影响,一定是先删除子记录,然后才能够删除父记录. 先删除多的一方,然后才能够删除一的一方. 级联删除 - 删除的一方之前先将这个一方的子记录全部删除 12345678910111213141516171819drop table t_ord;drop table t_customer;create table t_customer( id int(7), cname varchar(20) not null, constraint t_customer_id_pk primary key(id));insert into t_customer values(1,'admin');insert into t_customer values(2,'tom');create table t_ord( id int(7) primary key, ord_no varchar(20) not null unique, total double(7,2), customer_id int(7), constraint t_ord_customer_id_fk foreign key(customer_id) references t_customer(id) on delete cascade);insert into t_ord values(1,'1001',300,1);insert into t_ord values(2,'1002',300,null); delete from t_customer where id=1; 1 update语句 update 表 set 列名=列值,列名2=列值;//更新表中所有行 update 表 set 列名=列值,列名2=列值 WHERE条件;// truncate和delete和drop共同点 1.truncate和不带where子句的delete、以及drop都会删除表内的数据。 2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。 不同点 delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。 truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger 速度，一般来说: drop&gt; truncate &gt; delete 分页 limit m // 前m行 limit m,n // m从下标0开始(第一行),n显示行数 分页的公式123456public Page&lt;Book&gt; page(Integer pageNum,Integer pageSize){ // limit (pageNum-1)*pageSize,pageSize //1,3 0 //2,2 3} 分页的查询效率问题 limit m,n 其中的m叫做偏移量. 偏移量越大,分页的性能越低. 比如表1-100000,正好id=1,10000 select * from 表 where id&gt;条件 limit 2; 条件查询(减少偏移量) + limit 事务 用来执行一组SQL,是db中完成业务的基本单位. 事务ACID特性 原子性（Atomicity) - 事务不可再分割. 事务要么同时成功,同时失败 - 比如转账业务. 一致性(Consistency) - 事务一旦提交.内存中的数据要和磁盘上的数据要一致,保证数据的完整性. 比如tom-500,jack-500.无论转多少,转多少次.反正总的钱是1000 隔离性(isolation): 事务与事务之间的彼此隔离的,互不干扰的.一个事务的结束,意味着下一个事务的开始. 持久性(Durability) - 事务一旦提交,数据应该永久保存在磁盘中.即使发生一些故障,应该可以用一些恢复的技术进行恢复. 事务的分类 本地事务 - 一个项目(单体架构)连接一个数据库 分布式事务 消息中间件 - rabbitmq,rocketmq 阿里的框架seata 事务的隔离级别 ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 锁表. ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 一个事务只能读取到另外一个事务已经提交的数据. ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。产生脏读. 一个事务可以读取到另外一个事务尚未提交的数据 查询当前会话的隔离级别mysql默认的是可重复读的隔离级别 12345678910select @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+临时设置一下当前会话的事务的隔离级别set session transaction isolation level read uncommitted; 事务TCL命令 begin(开启一个事务),commit(提交一个事务),savepoint 事务点 set autocommit=0;//手动开启一个事务 DML操作默认都是会自动提交事务. 补充一点 rollback - 回滚事务 - 结束一个事务 不能回滚已经commit之后的事务. savepoint 事务点 rollback to 事务点 如果么有设置事务点 - 回滚当前事务中所有的操作. 1234567891011121314151617181920mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update t_acc set balance=balance+1000 where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; savepoint t1;Query OK, 0 rows affected (0.00 sec)mysql&gt; update t_acc set balance=balance+1000 where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; rollback to t1;Query OK, 0 rows affected (0.01 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) 多事务并发带来的问题 多个事务对同一个数据进行操作的时候,会产生一些问题 123456drop table t_acc;create table t_acc( id int,balance double(7,2));insert into t_acc values(1,10000),(2,10000); 脏读 一个事务读到了另外一个事务没有提交的数据 - 绝对不允许的. 不可重复读 set session transaction isolation level read committed; 一个事务A在读取一次之后,另外一个事务B在进行update操作.并且commit. A事务在没有自己没有提交之前,读取到了B事务提交之后的数据.导致A事务在当前事务中多次读取到的结果不一样. 幻读 它和不可重复读类似.侧重点不同.不可重复读强调的是一个事务在查询.另外一个事务在修改(update) 幻读强调的是一个事务在修改.另外一个事务在插入(insert). set session transaction isolation level read committed; 事务A在修改,事务B-insert并且提交了.事务A在本事务中再次查询,发现了好像有”更新失败”的数据.就像发生了幻觉一样. 可重复读 默认的隔离级别 set session transaction isolation level repeatable read; 事务A读取一次,事务B执行update操作.事务A在没有结束当前事务之前,多次读取到的结果是一样的. 必须要commit之后,才能够读取到B事务提交之后的修改数据. 总结 脏读 不可重复读 幻读 读未提交 √ √ √ 读已提交 × √ √ 可重复读 × × √ 串行化 × × ×","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"meet DB","slug":"meet-DB","permalink":"https://apelisun.github.io/tags/meet-DB/"}]},{"title":"mysql2","slug":"mysql2","date":"2022-08-09T13:22:58.000Z","updated":"2022-08-10T03:48:27.151Z","comments":true,"path":"2022/08/09/mysql2/","link":"","permalink":"https://apelisun.github.io/2022/08/09/mysql2/","excerpt":"","text":"视图-view 我们使用create命令来构建database,user,table(基本单位),view,索引,函数,存储过程,触发器 - 数据库的单位. 视图实际上就是一张”虚拟表”,实际上是不存在的.只是逻辑上的查询结果的集合. 视图的分类 简单视图 视图来自于单表查询的集合 - 允许执行DML操作 复杂视图 视图来自于多表关联查询的集合 - 不一定允许执行DML操作. 创建的语法12345DROP view 视图名;CREATE VIEW 视图名ASSELECT查询语句; 123create view t_acc_view as select * from t_acc;select * from t_acc_view; 复杂视图 12345678910111213drop view co_view;create view co_view asselect c.cname,o.ord_no from t_customer c join t_ord o on c.id = o.customer_id;update co_view set cname='xx'; //允许updatedrop view co_view;create view co_view asselect customer_id,count(*) c_ from t_ord group by customer_id;-- 不允许执行update操作.mysql&gt; update co_view set c_=1;ERROR 1288 (HY000): The target table co_view of the UPDATE is not updatable 测试 修改原表,视图肯定变化.有可能还会导致视图数据全部丢失. 123456789101112drop view t_acc_view;create view t_acc_viewasselect * from t_acc where balance=16000;-- 更新原表-- 更新了这个视图来源的那个条件列.update t_acc set balance = balance+1000 where id=2;mysql&gt; select * from t_acc_view;Empty set (0.00 sec) 修改视图 - 同样也会对原表造成影响. 12345678910111213141516drop view t_acc_view;create view t_acc_viewasselect * from t_acc where id=1;-- 更新视图update t_acc_view set balance=1000 where id=1;mysql&gt; select * from t_acc;+------+----------+| id | balance |+------+----------+| 1 | 1000.00 || 2 | 17000.00 || 3 | 15000.00 |+------+----------+ 针对题1的情况,更新列可能导致视图失效. 1234drop view t_acc_view;create view t_acc_viewasSELECT带where的条件查询语句 with check option with check option作用:不允许更新视图的来源的那个条件列. 肯定是要配合where语句一起使用的,否则没有任何意义 1234567drop view t_acc_view;create view t_acc_viewasselect * from t_acc where balance=1000 with check option;mysql&gt; update t_acc_view set balance=2000 where id=1;ERROR 1369 (HY000): CHECK OPTION failed 'dy.t_acc_view' 视图的好处 封装SQL语句 封装比较复杂的SQL语句,在Java中直接查询视图即可. 定制数据 系统不同的角色 - 看到的数据应该是不一样的. 安全性 数据库应该有多个user账号的,可以给不同的用户授予不同的视图的权限(select,insert,update,delete) 授权grant 合并抽离出去的数据 - 对用户屏蔽的底层的数据库的结构的设计. 索引-index 作用:提高查询的效率,类似于书的那个目录. 介绍 Myisam存储引擎 索引文件和数据文件是分开存储的.是俩个独立的文件 数据结构:B+树 Innodb存储引擎 数据和索引是合二为一的,是一个文件. B+树 索引也是占用物理空间的. 对表中的数据进行DML操作的时候,维护索引的-消耗一点额外的时间 如果表中某列重复的数据比较多,没有必要创建索引 - 查找的时候接近于全表扫描花费的时间. 当表中没有指定索引列,那么默认的索引列就是主键列. show index from 表名 \\G; 索引的分类 主键索引 1234Key_name: PRIMARY-- 非要删除主键约束alter table 表名 drop primary key; 唯一索引 1某列增加unique唯一约束,自动创建唯一索引 全文索引 后期会使用elasticsearch来进行全文搜索 - 搜索引擎. 复合索引 - 遵守最左匹配原则. 1create index index_name on 表名(列1,列2,列3); 普通索引 12create index index_name on 表名(列);drop index index_name; 索引失效场景※ 如何查看索引是否生效 - 索引执行计划explain select语句; type - const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all) type-all 全表扫描 - 索引是失效的. 123456explain select * from index_test where id=1;+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | index_test | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 脚本123456789101112131415161718drop table index_test;create table index_test( id int(7) primary key, a int(7), b int(7), c varchar(20), d varchar(20));insert into index_test values(1,100,10,'aaa','AAA');insert into index_test values(2,200,30,'aab','BBB');insert into index_test values(3,300,20,'caa','CCC');insert into index_test values(4,100,10,'daa','DDD');insert into index_test values(5,500,50,'aad','FFF');drop index index_test_index;create index index_test_index on index_test(a,b,c);create index index_test_d on index_test(d(10));//10 - 索引长度 1. 复合索引需要遵守最左匹配原则1234567891011121314151617181920-- a,b,c都是走了索引的.explain select * from index_test where a = 2 and b=200 and c='aaa';type:ref key_len: 73-- a走了索引explain select * from index_test where a = 2;type: ref key_len:5-- a,b都是走了索引explain select * from index_test where a = 2 and b=200;type:ref key_len:10-- b是不走的explain select * from index_test where b=200;type:ALL key_len:NULL-- type:ref key_len: 73-- mysql底层发现where条件列a,b,c都是复合索引,先进行优化,a,b,c,进行查询.explain select * from index_test where b=200 and c='aaa' and a=2; 2. 模糊匹配12345678-- %在末尾 - 生效explain select * from index_test where a = 2 and b=200 and c like 'a%';-- %在开头,a,b是走索引,但是c没有走索引explain select * from index_test where a = 2 and b=200 and c like '%a';-- %?%,a,b是走索引,但是c没有走索引explain select * from index_test where a = 2 and b=200 and c like '%a%'; 3. 查询范围之后12345-- b&gt;=10 条件成立,范围之后的索引是生效的. a,b,c都是走索引explain select * from index_test where a = 100 and b&gt;=10 and c='aaa';-- b&gt;10 条件不成立,范围之后的索引是失效的. 只有a,b是走索引的explain select * from index_test where a = 100 and b&gt;10 and c='aaa'; 4. 索引列参加了计算12-- type:ALLexplain select * from index_test where id+1=1; 5. 索引列使用了函数12-- type:ALLexplain select * from index_test where abs(id)=1; 6. 查询的数据超过整张表的30%7. is null和is not null1234567create index emp_index on s_emp(commission_pct);-- typ:ALL is null 没有走索引explain select * from s_emp where commission_pct is null;-- type:range is not 走索引.explain select * from s_emp where commission_pct is not null; 8. in和not in12345678explain select * from s_emp where id in(1,2,3);explain select * from s_emp where id not in(1,2,3);-- mysql5.7之前in - 走索引not in - 不走索引-- 8.x not in允许走索引 关于索引的长度key_len计算方式 数值类型 - int 4 + 1(该列是否为null,没有设置not null,就需要加1,存储null也占1个) 字符串类型 - varchar(n) - utf8 - n*3+2+1(没有设置not null,就需要加1,存储null也占1个) 索引长度作用 12345678site: www.baidu.com www.baobao.com www.baxy.com site索引长度是5,不够,前缀重复比较多.索引长度要有区分度.推荐反转之后进行存储.减少索引长度. 索引的创建策略 哪些列创建索引 主键列,唯一性列 重复性比较少,经常被查询但是同时更新不是特别频繁的列. order by + 排序列 - 创建索引. 12order by语句本身性能就很低下的. 根据索引进行排序.如果是id列索引,插入的时候就会先排序了. join on 列 12用来连接表的列适合建索引的.本身join越多,性能越低.开发中几乎都是单表查询.尽量不要去使用复杂查询. 不适合创建索引 null值太多的列 重复值太多的列 更新比较频繁的列 锁 行锁 123456begin;update s_emp set first_name='xxx' where id=1;//条件列是索引列 - 行锁 - 降低锁的粒度行锁和表锁1. 行锁粒度小,涉及到频繁的加锁和释放锁的过程.3. 表锁会影响到查询效率 1234begin;update s_emp set first_name='xxx' where id=1;//如果上面的事务没有commit,此处会阻塞如果此处更新的是另外一行,可以直接执行update s_emp set first_name='xxx' where id=2; 表锁 12非索引列条件更新的时候 - 锁表.所有的DML操作默认的申请表锁 页锁 介于行锁和表锁之间的. 共享锁 12345678910111213141516171819select语句默认申请的共享锁.select申请排他锁.select语句 for update;实现悲观锁更新库存stock伪代码:begin;select stock from xxx where id=1 for update;//更新stockcommit;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"view","slug":"view","permalink":"https://apelisun.github.io/tags/view/"}]},{"title":"mysql1","slug":"mysql1","date":"2022-08-09T13:22:47.000Z","updated":"2022-08-10T09:29:10.544Z","comments":true,"path":"2022/08/09/mysql1/","link":"","permalink":"https://apelisun.github.io/2022/08/09/mysql1/","excerpt":"","text":"数据库介绍 按照一定的数据结构来组织,管理和存储数据的仓库 用仓库的方式来管理数据的.一个仓库下会有很多表.一个表由行和列构成. 数据的分类 关系型数据库 表格型数据库 - 有行和列来构成一张表,表中存放数据 常见的产品:MS-sqlserver,主流的免费的Oracle-mysql(中小型的应用),收费的Oracle-oracle(大型的应用) nosql - 不仅仅是sql - 非关系型数据库 键值对数据库 - redis 文档型数据库 - mongodb 列式数据库 - hbase 图形数据库 数据库安装注意点 server和client 当我们安装好db之后,自带安装好了mysql-server端和mysql-client端 db正常使用,一定要保障mysql-server端处于运行状态 右击计算机 - 管理 - 服务 - 服务和应用程序 - 👉🏻右边窗口 - Mysql - 启动方式设置开启自启. 可以通过终端输入命令来启动mysql-server端 12net start mysqlnet stop mysql mysql-client客户端 第三方的收费navicat idea java代码 自带的控制台 专业术语 DB - DataBase 数据库 DBA - 数据库管理员(侧重于运维),DE - 数据库研发工程师 DBMS - 数据库管理系统,安装在操作系统.用户通过dbms来操作db,dba通过dbms来管理db,保证db在7*24h高效运转 人 - dbms - db(os) RDBMS - 关系型数据库管理系统 DBS - 数据库系统,大的范畴,dbs = dba+db+dbms 连接数据库 前提:mysql安装并且配置好了环境变量 1mysql -u用户名 -p密码 1mysql -uroot -proot 修改密码 12345678alter user '用户名'@'db所在主机ip' identified by '新的密码';use mysqlalter user 'root'@'localhost' identified by 'root';-- 退出重新登录exit; 导入脚本1234567891011121314151617181920212223242526272829-- 1. 创建数据库 create dabatase 数据库名create database dy;-- 查看所有的dbshow databases;-- 2. 使用数据库use dy-- 3. 导入脚本 - .sql为后缀的sql文件-- 3-1. 在dy数据库中生成5张表-- 3-2. 每张表中模拟一些数据source 脚本文件的绝对路径;-- 4. 查看该库下所有的表show tables;+--------------+| Tables_in_dy |+--------------+| s_customer || s_dept || s_emp || s_ord || s_region |+--------------+--5. 查看表结构desc s_emp 设置数据库编码 查看编码 1234567891011121314show variables like 'character_set%';+--------------------------+-----------------------------------------------------------+| Variable_name | Value |+--------------------------+-----------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+ 修改编码 2-1. 临时修改 - set命令 - 仅仅是对当前会话(一次连接,窗口)有效 1set names utf8; 2-2. 永久生效 - 找到my.ini文件 12345[client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]character_set_server=utf8 需要重启mysql-server(mysql服务器端),才能生效. 通过gui方式 通过命令 12net stop mysqlnet start mysql SQL介绍 SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。 ①mysql-client输入合法的sql语句,如果sql非法,直接报错 ②输入回车- 客户端将sql语句发送到mysql-server端,编译和解析sql语句的. ③mysql-server将执行完sql语句的结果返回到mysql-client进行展示. 按照功能SQL分类 DDL(Data Definition Language) - 数据定义语言 create drop alter truncate rename comment(注释) DML(Data Manipulation Language) - 数据操纵语言 update delete insert DQL(Data Query Language) - 数据查询语言 select TCL/DTL(Transaction Control Language):事务控制语言 commit savepoint rollback 简单查询 查询的本质 到哪里查 查什么 语法 - 关键字是大小写不敏感 12SELECT 列名1,列名2,..列nFROM 表名; 列取别名 查询员工的名字,薪水以及职称. 1select first_name,salary,title from s_emp; 方式一 1234SELECT 列名1 列别名,列名2 列别名,..列nFROM 表名;select first_name 名字,salary 薪水,title 职称 from s_emp; 方式二 1234SELECT 列名1 as 列别名,列名2 as 列别名,..列nFROM 表名;select first_name as 名字,salary as 薪水,title as 职称 from s_emp; 方式三 12列别名中间有空格,需要使用双引号来包裹格式select first_name \"名 字\",salary \"薪 水\",title as \"职 称\" from s_emp; 查询所有列* 1234-- 格式化输出select * from s_emp; select * from s_emp \\G; 去重关键字 distinct 查询员工表中所有的职称的信息 1select distinct title from s_emp; 列的计算 列是允许计算的 查询员工的名字,年薪(不带提成commission_pct) 1select first_name,salary*12 年薪 from s_emp; 查询员工的名字,年薪(带提成commission_pct) 123456789select first_name,salary*(1+commission_pct/100)*12 年薪 from s_emp; 查询出来只有5个人有年薪,原因是因为只有5个人有提成.其他人的提成都是null值mysql - null值计算的结果还是一个null值 使用到mysql中提供的空值置换函数coalesce(m,n) - 如果m为null,返回n,否则返回m select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp; 练习 找出员工的姓名,工资以及入职日期 12345select last_name,first_name,salary,start_date from s_emp;-- 列的拼接 concat(m,n,a,b,c,..)-- mysql中的字符串统一使用单引号select concat(last_name,' ',first_name) 姓名,salary,start_date from s_emp; 找出所有的客户名以及他的联系方式 1234select name,phone from s_customer;-- 查询姓名的时候-- 蔡根花 - 蔡** 找出每个订单的费用,支付方式以及出货日期 1select total,payment_type,date_ordered from s_ord; 条件查询123SELECT 列名1,列名2,..列nFROM 表名WHERE 条件表达式; 运算符比较运算符 1&gt; &lt; &gt;= &lt;= != &lt;&gt; = 其他运算符 between … and .. 在…到…之间 in(集合) - 在某个集合内 not in(集合) - 不在某个集合内 is - 判断是否为null,判断null值不能用= is not - 判断是否不为null 逻辑连接符 and 条件同时成立,返回true or 有一个条件成立,就返回true 练习 查询部门编号(dept_id)为41,42,45的员工找出来 1234select first_name,dept_id from s_empwhere dept_id=41 or dept_id=42 or dept_id=45;select first_name,dept_id from s_emp where dept_id in(41,42,45); 查询没有提成的员工 1select first_name,commission_pct from s_emp where commission_pct is null; 找出工资在[1200,1500]之间的员工 1234select first_name,salary from s_emp where salary between 1200 and 1500;-- 更加灵活select first_name,salary from s_emp where salary&gt;=1200 and salary&lt;=1500; 查找工资大于1500并且没有提成的员工 1select first_name,salary from s_emp where salary&gt;1500 and commission_pct is null; 查找年薪(包括提成)超过15000的员工 123456789select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 _year from s_empwhere salary*(1+coalesce(commission_pct,0)/100)*12&gt;15000;-- 给列取别名的意义-- 子查询 - 查询的结果作为虚拟表 - 子查询一定要放在()中select * from X where _year&gt;15000;查询的结果来替代X,子查询的结果作为表的话 - 需要给表取别名select * from (select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 _year from s_emp) core_ where _year&gt;15000; 找出除了41部门的员工 123select first_name,dept_id from s_emp where dept_id &lt;&gt; 41;select first_name,dept_id from s_emp where dept_id not in(41); 找出亚洲区域的信息 12-- mysql中采用单引号select * from s_region where name='Asia'; 模糊查询 大小写不敏感的 关键字like 占位符 % 代表的任意多个任意字符 _ 代表的是任意单个字符 转义字符 first_name名称正好包含了%或者_ 1update s_emp set first_name='Mar%k' where id=4; 查询first_name包含%的员工 12345-- 定义转义字符,默认的是\\select first_name from s_emp where first_name like '%\\%%'; -- 自定义转义字符,用escape 新的转义字符select first_name from s_emp where first_name like '%?%%' escape '?'; 练习 查询first_name包含m的 1select first_name from s_emp where first_name like '%m%'; 查询以C开头的员工 1select first_name from s_emp where first_name like 'C%'; 查询第三个字母是’e’的员工 1select first_name from s_emp where first_name like '__e%'; 查询入职时间是6月份的员工 - 模糊查询 - 不是正规的 1select first_name,start_date from s_emp where start_date like '%-06-%'; 排序1234567SELECT 列名1,列名2,..列nFROM 表名WHERE 条件表达式ORDER By语句 [asc|desc]asc可以省略不写 - 升序desc必须要写 - 降序 根据年薪降序排列 方式一: order by 列名 12select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 from s_emp order by salary*(1+coalesce(commission_pct,0)/100)*12 desc; 方式二: order by 列别名 12select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp order by 年薪 desc; 方式三: order by 列的序号 列的序号从1开始 =&gt; 推荐方式 12select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp order by 2 desc; 根据年薪降序排.如果年薪一样,则继续按照first_name升序排列 12select first_name,salary*(1+coalesce(commission_pct,0)/100)*12 年薪 from s_emp order by 2 desc,1; 转换函数数字和字符串 字符串转换成数字 123select '1'+0;mysql中字符数字遇到数字进行+,自动将字符转换成数字来进行计算. 数字转换成字符串 - concat函数 - 拼接删除 1select concat(1,2); // 12 字符串和日期 关于日期模板 123456789101112131415161718192021222324(在format字符串中可用标志符: %m 月名字(january……december) %w 星期名字(sunday……saturday) %d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(sun……sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(jan……dec) %j 一年中的天数(001……366) %H 24时制小时(00……23) %k 小时(0……23) %h 12时小时(01……12) %i 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [ap]m) %t 时间,24 小时(hh:mm:ss) %s 秒(00……59) %p am或pm %w 一个星期中的天数(0=sunday ……6=saturday ） 获取当前系统的日期 1234567select now();+---------------------+| now() |+---------------------+| 2022-08-05 11:09:49 |+---------------------+ 日期转换成指定格式的字符串 - date_format(日期,模板) 12345模板 %Y %m %d %H %i %sselect date_format(now(),'%Y/%m/%d %H:%i:%s');select date_format(now(),'%Y年%m月%d日 %H时%i分%s秒'); 字符串转成日期 - str_to_date(字符串,模板) - 字符串格式要和模板的格式匹配 12345678910111213141516171819202122232425-- 删除表drop table tt;-- 创建表create table tt( id int(7) primary key, name varchar(20), birthday date); -- date - 年月日-- 插入数据-- mysql中默认支持的格式 - 会将字符串自动转成date类型insert into tt values(1,'admin','2022-09-01');//okinsert into tt values(2,'tom','2022/09/01');//okinsert into tt values(3,'jack','20221001');//ok -- 不支持的时候insert into tt values(4,'jack','aa');ERROR 1292 (22007): Incorrect date value: 'aa' for column 'birthday' at row 1 insert into tt values(4,'jack','01-05-2022');ERROR 1292 (22007): Incorrect date value: '01-05-2022' for column 'birthday' at row 1 -- 非要使用'01-05-2022'字符串格式的,才需要使用str_to_date函数进行转换insert into tt values(4,'jack',str_to_date('01-05-2022','%d-%m-%Y')); 导入脚本的时候 - 失败场景 - 字符串日期格式不支持 单行函数 select 函数(参数); 函数是可以应用在查询列上的. 函数是允许嵌套使用的. 1. 字符串函数 instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0) lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 1select lpad('ab',5,'cd');//cdcab rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回 1select rpad('ab',5,'cd');//abcdc 5代表的是总的长度 left(str,len) - 返回字符串str的左端len个字符 right(str,len) - 返回字符串str的右端len个字符 substring(str,pos,len) - 返回字符串str的位置pos起len个字符 substring(str,pos) - 返回字符串str的位置pos起后面的子串 12序号从1开始select substring('mysql',2); //ysql ltrim(str) - 返回删除了左空格的字符串str rtrim(str) - 返回删除了右空格的字符串str space(n) - 返回由n个空格字符组成的一个字符串 replace(str,from_str,to_str) - 用字符串to_str替换字符串str中的子串from_str并返回 1select replace('i love java','java','mysql'); reverse(str) - 颠倒字符串str的字符顺序并返回 insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串 1select insert('xxxxx',1,2,'**'); lower(str) - 返回小写的字符串str upper(str) - 返回大写的字符串str char_length(str) - 不管汉字还是数字或者是字母都算是一个字符。 length(str);//汉字占3个,其他占1个. 练习 配合表 - 将first_name全部转换成大写 1select first_name,upper(first_name) from s_emp; first_name - 模拟银行账户显示,只显示首字母,其余每个字母用*表示 12345678910111213-- substring和rpadselect first_name,rpad(substring(first_name,1,1),char_length(first_name),'*') from s_emp;-- concat + substring + rpadselect first_name,concat(substring(first_name,1,1),rpad('*',char_length(first_name)-1,'*')) from s_emp;-- replace + substring + rpadselect first_name,replace(first_name,substring(first_name,2),rpad('*',char_length(first_name)-1,'*'))from s_emp;-- insert + rpadselect first_name,insert(first_name,2,char_length(first_name)-1,rpad('*',char_length(first_name)-1,'*'))from s_emp; 2. 数字函数 abs(n) - 求绝对值 mod(n,m) - 取模运算,返回n被m除的余数(同%操作符) floor(n) - 返回不大于n的最大整数值 - 向下取整 ceiling(n) - 返回不小于n的最小整数值 - 向上取整 round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0) pow(x,y) - 返回值x的y次幂 sqrt(n) - 返回非负数n的平方根 pi() - 返回圆周率 rand() - 返回在范围[0到1.0)内的随机浮点值 truncate(n,d) - 保留数字n的d位小数并返回 - 直接截取 3. 日期函数 查询当前系统的日期 - select now(); dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准) weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天) year(date) - 返回date的年份(范围在1000到9999) month(date) - 返回date中的月份数值 dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内) hour(time) - 返回time的小时数(范围是0到23) minute(time) - 返回time的分钟数(范围是0到59) second(time) - 返回time的秒数(范围是0到59) period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) mysql&gt;select period_add(‘202008’,3) ; 注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型. period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm) p1-p2 curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字) now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字) last_day(date) - date日期所在月的最后一天是什么时候 datediff(d1,d2) - 两个日期d1,d2之间相差的天数 timestampdiff(type,d1,d2) - type是YEAR,d1和d2相差的年份,MONTH,月份 d1,d2 - yyyymmdd 3-1. 补充 date_add(date,interval expr type) date_sub(date,interval expr type) 关于type 1234567ype:yearmonthdayhourminutesecond #关联查询 关联查询就是多表查询 错误的写法 s_emp表中25rows,s_dept表中12rows 查询员工的名字以及这个员工的部门名称 12345select first_name,name from s_emp,s_dept;300 rows 发生了笛卡尔积 - 错误的结果 纠正 - 传统的写法1234567891011121314151617181920212223select first_name,name from s_emp,s_dept where dept_id=id;ERROR 1052 (23000): Column 'id' in where clause is ambiguous多张表中出现同名的列,需要对表取别名正确的写法:select e.first_name,d.name from s_emp e,s_dept d where e.dept_id=d.id;-- 用来表示表与表之间的关系foreign key - 外键-- 查询这个员工的first_name以及这个员工所在的区域名.-- 一个区域对应多个部门,一个部门对应多个员工.select e.first_name,r.name from s_emp e,s_dept d,s_region rwhere d.region_id = r.id and e.dept_id = d.id;for( ... s_emp e){ for(... s_dept d){ if(e.dept_id==d.id){ e+\":\"+d } }} join和on写法 如果一条sql语句涉及到的表比较多的话,传统的写法,就不能很直观的看出来哪个表和哪个表之间有直接的关系. 表 join 表 on 去除笛卡尔积 外键一定是出现在多的一方 on 多的一方的外键 = 一的一方主键 但是也不一定非要使用外键来去除笛卡尔积 规则: 能够用join连接的表之间必须要有直接的关系. 练习 找出查询员工的名字以及这个员工的部门名称 1select e.first_name,d.name from s_emp e join s_dept d on e.dept_id = d.id; 找出’Asia’区域上的所有的员工 123456select e.first_name,r.name from s_emp e join s_dept don e.dept_id = d.idjoin s_region ron d.region_id = r.idwhere r.name='Asia'; 找出客户的id,名称,联系方式以及这个客户的订单信息 ‘问题 - 15rows - [201,215]’ 1234select c.id,c.name,c.phone,o.* from s_customer cjoin s_ord o on c.id = o.customer_id;查询出来的结果缺了id=207和215俩个客户,因为这俩个客户没有订单,所以这俩个客户没有查询出来. 连接的方式 内连接 - [inner] join 如果join左边的表在右边的表中如果不存记录,则不会被查询出来. 12select c.id,c.name,c.phone,o.id from s_customer cinner join s_ord o on c.id = o.customer_id; 左连接 - left join 以左边的表为基准表.即使左边的表在右边的表中没有记录,那么左边表中的这条记录也要能够被查询出来 查询客户和订单信息,即使这个客户没有订单,那么这个客户也要能够被查询出来 12select c.id,c.name,c.phone,o.id from s_customer cleft join s_ord o on c.id = o.customer_id; 右连接 - right join 以右边的表为基准表.即使右边的表在左边的表中没有记录,那么右边表中的这条记录也要能够被查询出来 查询客户和订单信息,即使这个客户没有订单,那么这个客户也要能够被查询出来 12select c.id,c.name,c.phone,o.id from s_ord oright join s_customer c on c.id = o.customer_id; 交叉连接 - cross join - 不会使用的,产生的是一个错误的结果集 - 笛卡尔积 12select c.id,c.name,c.phone,o.id from s_customer ccross join s_ord o; 全连接 full outer join - mysql不支持 全连接 = 左连接 + 右连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364drop table t_user;drop table t_info;create table t_user( id int primary key, name varchar(20));insert into t_user values(1,'admin');insert into t_user values(2,'python');create table t_info( id int primary key, remark varchar(20), user_id int);insert into t_info values(1,'aaa',1);insert into t_info values(2,'bbb',3);-- 分析 - 左连接select u.*,info.* from t_user u left join t_info info on u.id = info.user_id;+----+--------+------+--------+---------+| id | name | id | remark | user_id |+----+--------+------+--------+---------+| 1 | admin | 1 | aaa | 1 || 2 | python | NULL | NULL | NULL |+----+--------+------+--------+---------+-- 右连接select info.*,u.* from t_user u right join t_info info on u.id = info.user_id;+----+--------+---------+------+-------+| id | remark | user_id | id | name |+----+--------+---------+------+-------+| 1 | aaa | 1 | 1 | admin || 2 | bbb | 3 | NULL | NULL |+----+--------+---------+------+-------+-- 全连接union - 两张表中的重复的结果保留了一条 union all - 两张表中的重复的结果都会展示出来 , 并集select u.*,info.* from t_user u left join t_info info on u.id = info.user_idunion allselect u.*,info.* from t_user u right join t_info info on u.id = info.user_id; id | name | id | remark | user_id |+------+--------+------+--------+---------+| 1 | admin | 1 | aaa | 1 || 2 | python | NULL | NULL | NULL || 1 | admin | 1 | aaa | 1 || NULL | NULL | 2 | bbb | 3 |+------+--------+------+--------+---------+select u.*,info.* from t_user u left join t_info info on u.id = info.user_idunion select u.*,info.* from t_user u right join t_info info on u.id = info.user_id;+------+--------+------+--------+---------+| id | name | id | remark | user_id |+------+--------+------+--------+---------+| 1 | admin | 1 | aaa | 1 || 2 | python | NULL | NULL | NULL || NULL | NULL | 2 | bbb | 3 |+------+--------+------+--------+---------+ 练习 查询员工的名称以及他对应的上司的名称,即使这个员工没有上司,那么也要查询出来 - 自关联 12select e1.first_name 员工,e2.first_name 上司from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id; 多行函数 count - 统计个数,null值不会统计,重复的数据,有一个算一个 12345678select count(*) from s_emp;select count(e.id) from s_emp e;select count(e.commission_pct) from s_emp;//5个-- 统计职称的个数,但是重复的职称只能算1个select count(distinct title) from s_emp; sum - 总和,忽略null值 avg,max,min 分组查询 分组统计 语法 12345SELECT 语句WHERE 语句GROUP BY 语句HAVING 语句ORDER BY 语句 练习 统计每个部门的员工的个数 - 单表 1select e.dept_id,count(e.id) from s_emp e group by e.dept_id; 统计部门的id,name以及这个部门的员工的个数 123456789101112-- group by + d.id --- ok id是主键列 - 唯一性select d.id,d.name,count(e.id) from s_emp ejoin s_dept d on e.dept_id = d.id group by d.id;select d.id,d.name,count(e.id) from s_emp ejoin s_dept d on e.dept_id = d.id group by d.name;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'dy.d.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by-- 推荐select后面跟的列(除了组函数/多行函数)应该和group by 跟的列保持一致select d.id,d.name,count(e.id) from s_emp ejoin s_dept d on e.dept_id = d.id group by d.id,d.name; 统计每个职称的人数 1select title,count(*) from s_emp group by title; 统计区域id,区域名,以及这个区域上的员工的个数 12select r.id,r.name,count(e.id) from s_region r join s_dept don d.region_id = r.id join s_emp e on e.dept_id = d.id group by r.id,r.name; 统计客户的id,name以及这个客户的订单的数量,没有订单,则显示0 12select c.id,c.name,count(o.id) from s_customer c left join s_ord oon o.customer_id = c.id group by c.id,c.name; 统计各年份入职的员工(年份,员工数量) 12select year(start_date),count(e.id) from s_emp egroup by year(start_date); having使用方式 having和where区别 where条件筛选,但是分组之前,并且where不会跟组函数 having分组之后的进一步过滤,使用组函数进行过滤的 练习 查询出平均工资超过1300的部门 - 部门id,name,平均工资 12select d.id,d.name,avg(e.salary) from s_dept d join s_emp eon d.id = e.dept_id group by d.id,d.name having avg(e.salary)&gt;1300; 统计除了’Asia’区域之外的各个区域的id,name和区域上的人数[大于3个],最后再根据区域的id进行降序排列 1234567select r.id,r.name,count(e.id) from s_region r join s_dept d on r.id = d.region_idjoin s_emp e on e.dept_id = d.idwhere r.name&lt;&gt;'Asia'group by r.id,r.namehaving count(e.id)&gt;3order by 1 desc; 查询没有订单的客户 12select c.id,c.name,count(o.id) from s_customer cleft join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)=0; 子查询 子查询必须使用()括起来 条件列 查询列 子查询的结果看做是”一张表” 练习 查找和Mark工资一样的员工. 123456789-- 分解 - mark工资 - 1450select salary from s_emp where first_name='Mark';-- 找出1450薪资的员工select first_name,salary from s_emp where salary = 1450 and first_name&lt;&gt;'Mark';-- 整合-- 子查询出现在条件部分select first_name,salary from s_emp where salary = (select salary from s_emp where first_name='Mark') and first_name&lt;&gt;'Mark'; 统计每个部门的id,name以及部门的员工的个数 123select d.id,d.name,( select count(e.id) from s_emp e where e.dept_id = d.id) from s_dept d; 练习2 统计客户的id,name以及客户的订单数量 1select c.id,c.name,(select count(o.id) from s_ord o where o.customer_id = c.id) from s_customer c; 找出部门平均工资高于公司平均工资的部门信息 1select dept_id,avg(salary) from s_emp group by dept_id having avg(salary)&gt;(select avg(salary) from s_emp); 找出与’Ben’同部门的员工信息 12345678910-- 方式一select first_name,dept_id from s_emp where dept_id=(select dept_id from s_emp where first_name='Ben')and first_name&lt;&gt;'Ben';-- 方式二select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name='Ben' and e1.dept_id=e.dept_id) did from s_emp e where e.first_name&lt;&gt;'Ben';-- 方式二整合 - 把子查询的结果作为一张表,必须要别名select * from (select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name='Ben' and e1.dept_id=e.dept_id) did from s_emp e where e.first_name&lt;&gt;'Ben') core_where core_.did is not null; 总结 能用分组查询查询就不要使用子查询(嵌套越多,查询效率越低) 无关子查询(子查询可以独立运行)和相关子查询(子查询使用到了外部查询的东西) 无关子查询&gt;相关子查询 子查询会比分组查询更加灵活. exists和not exists 1234567SELECT 语句WHERE exists (子查询)规则: 不关心子查询查到的内容是什么,子查询是否能够查询出结果.如果查询出结果,等同于where trueselect id,first_name from s_emp where exists(select 1 from s_emp where 1=1); 找出和'Ben'同一个部门的员工 1234select e.first_name,e.dept_id from s_emp e where exists(select 1 from s_emp e1 where e1.first_name='Ben' and e1.dept_id = e.dept_id) and e.first_name&lt;&gt;'Ben'; 练习 找出各个部门工资排名前二的员工 思路: 在’我’这个部门中,有人的工资比我高,但是数量不能超过1个 12345select e.id,e.salary,e.dept_id from s_emp ewhere exists( select 1 from s_emp e1 where e1.dept_id = e.dept_id ande1.salary&gt;e.salary having count(*)&lt;=1) order by 3; 练习 找出每个部门中工资最高的那个人","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"数据库基础","slug":"数据库基础","permalink":"https://apelisun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"}]},{"title":"索引","slug":"索引","date":"2022-08-09T11:22:53.000Z","updated":"2022-08-10T03:53:20.348Z","comments":true,"path":"2022/08/09/索引/","link":"","permalink":"https://apelisun.github.io/2022/08/09/%E7%B4%A2%E5%BC%95/","excerpt":"","text":"view create view123456789drop view student_view;create view student_view as select *from t_student where id%2=0;-- insert into t_studentinsert into t_student values(5,'java',20),(6,'javab',25),(7,'sad',20),(8,'jksd',56);-- update student_viewupdate student_view set age=100 where id=8; create complex view1234567891011121314151617181920212223242526272829303132333435363738394041-- 有关系的两张表（fk）drop view student_view2;create view student_view2 as select s.*,sc.c_id from t_student s left join t_sc sc on s.id=sc.s_id;-- update viewupdate student_view2 set name='as' ;ERROR 1288 (HY000): The target table student_view2 of the UPDATE is not updatable-- 无关系的两张表drop table tt;drop table ta;create table tt( id int(7) primary key,tname varchar(20));create table ta( taid int(7) primary key,tt_id int(7));insert into tt values(1,'aa');insert into tt values(2,'aa');insert into tt values(3,'aa');insert into tt values(4,'aa');insert into ta values(1,1);insert into ta values(2,2);insert into ta values(3,3);insert into ta values(4,4);drop view t_view;create view t_view as select * from tt t join ta a on a.tt_id=t.id;update t_view set tname='as';create view t_view2 as select count(*)from tt t join ta a on a.tt_id=t.id;update t_view set count=10;视图作用：1.封装sql 2.屏蔽底层数据库结构 3.定制数据 4.安全性（grant） 索引123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869-- function:提高查询效率底层：b+数 myisam（数据，索引分别存储）,innodb(数据，索引合二为一)-- 主键列默认索引列show index from 表名-- 索引分类1.主键索引（primary key）2.unique3.全文索引（elasticsearch）4.复合索引create index index_name on tablename(column 1,column 2)5.普通索引create index index_name on tablename(colunmn)drop table index_test;create table index_test(id int(7) primary key auto_increment,a int(7),b int(7),c varchar(20),d varchar(20));insert into index_test values(1,2,3,'20w','cc'),(null,22,93,'2s0','dd'),(null,22,33,'w20','ss'),(null,22,53,'201','hh'),(null,72,43,'200','gg'),(null,2,3,'20i','ff');drop index t_index;create index t_index on index_test(a,b,c);-- jude index validexplain +select....explain select * from index_test where a=2 and b=3 and c='20w';(ref) len=93 +----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | index_test | NULL | ref | t_index | t_index | 93 | const,const,const | 1 | 100.00 | NULL |+----+-------------+------------+------------+------+---------------+---------+---------+-------------------+------+----------+-------+-- 索引失效*1.复合索引最左匹配原则explain select *from index_test where b=3 and c='20w';(All len=0)explain select *from index_test where a=3 and b=2;(ref len=10)explain select *from index_test where c='sd' and a=10 and b=2;(ref len=93),调优2.模糊匹配-- %在末尾生效explain select * from index_test where a=1 and b=2 and c like 's%';(ref len=93)%在前部分生效同（%？%）explain select * from index_test where a=1 and b=2 and c like '%s';(ref len=10)-- a,b走索引3.查询范围explain select * from index_test where a=1 and b&gt;2 and c='21';(ref len=10)4.索引计算explain select* from index_test where id+1=1;(all)5.索引使用函数explain select* from index_test where abs(id)=1;(all)6.c查询数据超过百分之30（数据量足够大）7.is null and is not null(is null 不走索引，is not null 走索引)8.in and not inbefore 5.7 in(走索引) not in(不走)after 8.0 not in ( allow index)-- 索引的创建策略-- fit create index1.primary key or unique2.重复性少，经常被查询，但是更新少3.order by 列4.join on 列-- unfit create index1.null值列2.重复列3.更新频繁列 锁1234567891.行锁（两线程不能同时修改某一行的值）update XX set xx=xx where id=1;//必须是索引列，降低锁的粒度2.表锁（非索引列为条件更新 会触发表锁）所有的DML操作都会阻塞3.页锁（介于行锁与表锁之间）一页：由若干行组成的数据（B+树）4.共享锁（select,类似Java的读锁）-- select语句申请排他锁select stock from xxx where id=1 for update;（悲观锁：干啥都悲观，总担心有人改数据，索性给全锁了） 索引底层原理12345678910111213myisam(mai se meng),innoDB-----&gt;B+树二叉查找树-&gt;二叉搜索树-&gt;B+树二叉查找树（失衡）--&gt;（产生）二叉平衡树（数据节点过多）-&gt;B树（储存一页数据，key和value都存）-&gt;b+树B+树1.非页节点存储key2.数据存叶子，且相对有序3.页与页（树节点）之间是双向链表4.叶子内部数据是单向链表 B+树– 聚簇索引 聚簇索引与非聚簇索引123456innoDB为引擎的表，表中的数据都会有主键，即使不主动声明，系统会创建一个隐式的主键.B+树的键值就是主键.这种**以主键为B+树索引而构成的B+树***索引，称为聚簇索引非聚簇索引：以其他列值构建B+树的索引-- 非聚集索引的叶子节点并不存储数据，而是存储对应的主键，因此还需要通过索引查数据，称之为回表（注，若所查数据为主键列，或者该列，则不需要回表） 1select * from xx where id&gt;=18 and id&lt;41; 非聚簇索引查找图 myisam查找图 123456789101112key - 索引列值,value - 数据行的物理地址.innodb中索引和数据合并到一个文件中myisam中索引和数据是单独的俩个文件,分别是索引文件和数据文件.myisam中采用的是\"非聚集的方式\"无论是聚簇索引还是非聚簇索引,查找方式是一样.采用的也是B+树的结构**.只是叶节点中存储的是索引的列值以及该对应的行记录的地址.**需要再根据行记录地址到表中进行定位[回表] 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344delimiter $$create function dy_add(a int ,b int) returns int begin return a+b; end $$delimiter ;select dy_add(5,2);delimiter $$create function dy_add(a int ,b int) returns int begin return a+b; end $$delimiter ;select dy_add(5,2);-- 触发器drop trigger customer_trriger;delimiter //create trigger customer_trriger before delete on s_customer for each rowbegindelete from s_ord where customer_id=old.id;end //delimiter ;-- 触发器drop trigger customer_trriger;delimiter //create trigger customer_trriger before insert on s_customer for each rowbegin if new.id&lt;5 select 'error';end //delimiter ;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"index","slug":"index","permalink":"https://apelisun.github.io/tags/index/"}]},{"title":"mysql四种分区","slug":"mysql四种分区","date":"2022-08-08T13:04:23.000Z","updated":"2022-08-10T03:51:25.690Z","comments":true,"path":"2022/08/08/mysql四种分区/","link":"","permalink":"https://apelisun.github.io/2022/08/08/mysql%E5%9B%9B%E7%A7%8D%E5%88%86%E5%8C%BA/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546drop table t_user;create table t_user(id int(7) primary key comment '主键',name varchar(20) not null unique comment '姓名',birthday date default '2022-02-08');drop table t_account;create table t_account(id int(7),blance double(5,2),u_id int(7) ,constraint t_account_id_pk primary key(id),constraint t_account_id_fk foreign key(u_id) references t_user(id));drop table t_student;drop table t_course;drop table t_sccreate table t_student(id int(7) primary key,name varchar(20) unique not null,age int(7) default 20);create table t_course(id int(7) primary key,name varchar(20) not null);create table t_sc(id int(7),s_id int (7),c_id int(7),constraint t_sc_id_pk primary key(id),constraint t_sc_s_id_fk foreign key(s_id) references t_student(id),constraint t_sc_c_id_fk foreign key(c_id) references t_course(id));insert into t_student values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null);insert into t_course values(1,'math'),(2,'english'),(3,'chinses'),(4,'chesmatical');insert into t_sc values(1,1,1),(2,2,3),(3,4,2),(4,3,4); 12345678910111213--测试表格及数据drop table hashTest;create table hashTest(id int(7) primary key,name varchar(20),age int(7))PARTITION BY HASH(id) PARTITIONS 4;;insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);--查询分区结构SELECT PARTITION_NAME,PARTITION_METHOD,PARTITION_EXPRESSION,PARTITION_DESCRIPTION,TABLE_ROWSFROM `information_schema`.`PARTITIONS`WHERE TABLE_SCHEMA=SCHEMA() AND TABLE_NAME='hashTest'; hash分区 PARTITIONS=4(4个分区，根据取模确定不同id的占据区域)123456789+----------------+------------------+----------------------+-----------------------+------------+| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |+----------------+------------------+----------------------+-----------------------+------------+| p0 | HASH | `id` | NULL | 3 || p1 | HASH | `id` | NULL | 3 || p2 | HASH | `id` | NULL | 3 || p3 | HASH | `id` | NULL | 3 |+----------------+------------------+----------------------+-----------------------+------------+ Range分区 分成6个分区123456789101112131415161718192021222324252627drop table hashTest;create table hashTest(id int(7) primary key,name varchar(20),age int(7))PARTITION BY RANGE (id) PARTITIONS 6 ( PARTITION part0 VALUES LESS THAN (2) , PARTITION part1 VALUES LESS THAN (4) , PARTITION part2 VALUES LESS THAN (6) , PARTITION part3 VALUES LESS THAN (8) , PARTITION part4 VALUES LESS THAN (10), PARTITION part5 VALUES LESS THAN (13));insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);分区结果：+----------------+------------------+----------------------+-----------------------+------------+| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |+----------------+------------------+----------------------+-----------------------+------------+| part0 | RANGE | `id` | 2 | 1 || part1 | RANGE | `id` | 4 | 2 || part2 | RANGE | `id` | 6 | 2 || part3 | RANGE | `id` | 8 | 2 || part4 | RANGE | `id` | 10 | 2 || part5 | RANGE | `id` | 13 | 3 |+----------------+------------------+----------------------+-----------------------+------------+ list分区1234567891011121314151617181920212223drop table hashTest;create table hashTest(id int(7) primary key,name varchar(20),age int(7))PARTITION BY LIST(id) ( PARTITION pNorth VALUES IN (1,2,3), PARTITION pEast VALUES IN (5,6,7), PARTITION pWest VALUES IN (4,8,9), PARTITION pCentral VALUES IN (10,11,12));insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);--分区结果：+----------------+------------------+----------------------+-----------------------+------------+| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |+----------------+------------------+----------------------+-----------------------+------------+| pCentral | LIST | `id` | 10,11,12 | 3 || pEast | LIST | `id` | 5,6,7 | 3 || pNorth | LIST | `id` | 1,2,3 | 3 || pWest | LIST | `id` | 4,8,9 | 3 |+----------------+------------------+----------------------+-----------------------+------------+ key分区（和hash分区类似，其分区函数是由mysql内部确定的）1234567891011121314151617drop table hashTest;create table hashTest(id int(7) primary key,name varchar(20),age int(7))PARTITION BY KEY()PARTITIONS 2;insert into hashTest values(1,'tom',20),(2,'cca',22),(3,'kkp',21),(4,'see',null),(5,'tom',20),(6,'cca',22),(7,'kkp',21),(8,'see',null),(9,'tom',20),(10,'cca',22),(11,'kkp',21),(12,'see',null);--分区结果+----------------+------------------+----------------------+-----------------------+------------+| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION | TABLE_ROWS |+----------------+------------------+----------------------+-----------------------+------------+| p0 | KEY | NULL | NULL | 6 || p1 | KEY | NULL | NULL | 6 |+----------------+------------------+----------------------+-----------------------+------------+","categories":[],"tags":[{"name":"msql","slug":"msql","permalink":"https://apelisun.github.io/tags/msql/"},{"name":"area","slug":"area","permalink":"https://apelisun.github.io/tags/area/"}]},{"title":"集合","slug":"集合","date":"2022-08-08T13:03:53.000Z","updated":"2022-08-10T03:53:10.241Z","comments":true,"path":"2022/08/08/集合/","link":"","permalink":"https://apelisun.github.io/2022/08/08/%E9%9B%86%E5%90%88/","excerpt":"","text":"集合框架 就是一个内存中的”容器”,用来存储数据.实际开发中用来替代数组的使用 不同的集合框架底层使用到的数据结构不一样. api包:java.util Collection[I] List[I] - 有序,可重复 ArrayList[C] - “底层就是动态数组 - 内存中是连续的,有序的 - 便于使用下标来访问元素.但是增删效率略低” LinkedList[C] - “底层是一个双向链表,访问比ArrayList慢,但是增删效率高” 适合解决栈列和队列的业务 - 贪吃蛇 Vector[C] - 线程安全的,使用方式和ArrayList一致. Set[I] - 无序,不可重复 HashSet[C] - “底层使用的哈希算法,底层就是HashMap” SortedSet[I] TreeSet[C] - “可以使用可比较接口或者比较器接口来实现排序的功能,但是仍然是不可重复的” “底层是TreeMap” Map[I] - 采用key-value键值对形式来存储数据 HashMap[C] - 针对key无序不可重复 Hashtable[C] Properties[C] - .properties属性文件在内存中映射的那个对象 迭代器Iterator 作用 - 为了访问不同数据结构的集合,提供了一种统一的方式. ArrayList 123456789101112131415161718192021222324252627public Iterator&lt;E&gt; iterator() { return new Itr();}private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } @SuppressWarnings(\"unchecked\") public E next() { checkForComodification();//检测expectedModCount == modCount; int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); //集合存储的数据 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; // 数组对象[下标] }} LinkedList 1234567891011121314151617181920212223242526272829303132333435363738private class Itr implements Iterator&lt;E&gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } }} ArrayList练习 集合中添加N个图书对象,将图书名包含java的图书全部删除! ArrayList扩容机制 第一次调用add方法的时候,才会初始化数组elementData 默认的数组的长度是10个 扩容的倍数是1.5倍 ArrayList和Vector区别 要想回答这个问题，可以先把各种都讲特性，然后再从底层存储结构，线程安全，默认大小，扩容机制，迭代器，增删改查效率这几个方向入手。 底层存储数据结构 - 本质上都是数组,Vector是使用队列[先进先出]来存储数据,但是本质仍然是数组. 线程安全性 - 前者是线程不安全,后者是线程安全 默认大小 - 俩者都是长度为10 扩容机制 - 前者是1.5倍,后者默认是扩容2倍,可以扩容系数可以设置的. ArrayList和Vector检索元素，由于是数组，时间复杂度是O(1)，在集合的尾部插入或者删除是O(1)，但是其他的地方增加，删除，都是O(n)，因为涉及到了数组元素的移动 ArrayList的删除和插入的效率一定会比LinkedList低吗? - 不一定,看是否操作的是集合的尾部 LinkedList jdk8.0用到的是双向链表结构 链表肯定会比数组占用更多的内存 阔以模拟栈列和队列的业务 单向链表结构 - 必须从头节点开始 element - 真实的数据 next - 下一个节点的地址 单向循环结构 get(int index)底层 1234public E get(int index) {checkElementIndex(index);return node(index).item;} 内部类 123456789101112private static class Node&lt;E&gt; {E item;Node&lt;E&gt; next;Node&lt;E&gt; prev;Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev;}} 核心方法node(index) 12345678910111213141516Node&lt;E&gt; node(int index) {// index=2// 1 2 3 4 5 6 = size = 6if (index &lt; (size &gt;&gt; 1)) { // 如果在中间位置的左边 Node&lt;E&gt; x = first; // 头节点开始遍历 for (int i = 0; i &lt; index; i++) x = x.next; return x;} else { // 从尾部 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x;}} remove(int index)底层1234public E remove(int index) { checkElementIndex(index); return unlink(node(index));} unlink(node(index)); 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) { // x-即将删除的节点 // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 下一个节点 final Node&lt;E&gt; prev = x.prev; //上一个节点 if (prev == null) { // 判断x是否为头节点 first = next; // 原来第二个节点设置成头节点 } else { prev.next = next; //原来上一个节点的下一个地址应该指向原来这个节点的下一个节点 x.prev = null;//gc } if (next == null) { // 判断x是否为尾节点 last = prev; // 倒数第二个节点设置成尾结点 } else { next.prev = prev; x.next = null;//gc } x.item = null;//gc size--; // 集合的长度 modCount++; // 并发修改 return element;//返回刚刚删除的元素} 作业 括号匹配 1234567891011()[]{}()[]{}([{}])[()]{}(]([)]{}​~~~java arr = ( [ { } ] ) 永远将第一个元素压入栈顶 push从arr的第2个位置开始遍历i下标对应的元素,和栈顶元素进行比较getFast();不匹配 - 继续压入栈顶匹配 - 弹出栈顶集合是否为空 isEmpty(); ( [ ) ] { } ])[( 1 123456789101112131415161718192021222324public class Purcase{ //购买类 private String brand; //品牌 private String name; //产品名 private double cost; // 费用 //构造,getter/setter,toString...}List&lt;Purcase&gt; list = new ArrayList&lt;&gt;();Purcase p1 = new Purcase(\"宝洁\",\"洗手粉\",18.5);Purcase p2 = new Purcase(\"联合利华\",\"肥皂\",4.5);Purcase p3 = new Purcase(\"宝洁\",\"牙膏\",32.5);Purcase p4 = new Purcase(\"宝洁\",\"毛巾\",14.5);Purcase p5 = new Purcase(\"洁利\",\"洗面奶\",26.0);Purcase p6 = new Purcase(\"好迪\",\"洗发水\",27.5);Purcase p7 = new Purcase(\"多芬\",\"沐浴露\",38.5);Purcase p8 = new Purcase(\"宝洁\",\"洗洁精\",3.4);list.add(p1);list.add(p2);....要求:写一个程序,打印出各品牌所花费的总费用①.[可选,排好序后再打印输出,按花费总费用的降序排序②] map =&gt; 统计每个随机数出现的次数. 15个随机数 1~5 “python java 123 15901121 dfdfd fdfd” 贪吃蛇的实现步骤 输出一个主界面 蛇身(LinkedList-&gt;存储了N个Node) - 长度,蛇头,方向 随机生成n个食物 - 使用HashSet来进行存储 123456* * * * * * * * * * ** 0* # # # * 0 0** 创建一个对象Node(int x,int y); 创建一个类SnakeGame 3-1. 创建一个内部类Snake - 维护一个LinkedList 3-2. Set foods = new HashSet&lt;&gt;();//存放食物 走一步算法 4-1. 没有吃到食物 12341. 确定新的方向 - w a s d2. 新的坐标Node(i,j)3. addFirst - 将新的坐标放入到蛇头4. 判断新的坐标是否属于foods,如果不属于removeLast();//删除最后尾节点 4-2. 吃到食物 HashSet HashSet和HashMap =&gt; 存放数据的性能 - HashMap更高 - HashSet可能是计算整个对象的hashCode方法 123456789101112Set&lt;Book&gt; set = new HashSet&lt;&gt;();public HashSet() { map = new HashMap&lt;&gt;();}set.add(10);//set集合的value就是map集合的keypublic boolean add(E e) { return map.put(e, PRESENT)==null;} HashMap 线程不安全的. 用到的数据结构 jdk8.0-开始桶数组 + 单向链表 + 红黑树 桶 - 哈希桶 put底层源码剖析12345678910111213141516171819HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();//扩容因子 - 预扩容static final float DEFAULT_LOAD_FACTOR = 0.75f;public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}//put方法public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}//针对ke进行一个hash算法 - 扰动函数static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 让哈希值和高16位进行异或运算} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 transient Node&lt;K,V&gt;[] table;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //①进来table和tab都是null if ((tab = table) == null || (n = tab.length) == 0) //①就会执行扩容操作 n = 16 tab初始化完毕 n = (tab = resize()).length; //①hash - key的扰动函数得到哈希值 //(n - 1) &amp; hash =&gt; 1. 下标肯定不会越界 2. 减少哈希冲突 //p = tab[哈希位置]肯定是null if ((p = tab[i = (n - 1) &amp; hash]) == null) //①对这个位置进行赋值操作 //单向链表 tab[i] = newNode(hash, key, value, null);//最后一个参数是next else { Node&lt;K,V&gt; e; K k; //p - 哈希冲突的位置上的Node //比较node对象的hash值 //俩个确实是同一个对象 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;//e = p是旧的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { //OO - 不同对象的hashCode值,不一定 // 哈希碰撞了,但是并不是俩个相同的对象 //b. 相同对象equals肯定返回true for (int binCount = 0; ; ++binCount) { //把哈希冲突位置上的旧节点p的next挂载一个新的e if ((e = p.next) == null) {//①肯定为空 p.next = newNode(hash, key, value, null); //当链表长度开始&gt;=8的时候,单向链表结构就会转换成红黑树 //删除操作 - 如果节点个数小于等于6的时候,开始转成链表结构 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //链表的节点可能和新插入的节点是一个相同对象 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value;//就是旧的节点的value if (!onlyIfAbsent || oldValue == null) e.value = value;//新的value赋值给旧节点的value afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 扩容resize() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16final Node&lt;K,V&gt;[] resize() { //第一次进来oldTab就是null Node&lt;K,V&gt;[] oldTab = table; //oldCap 旧容量 = 0 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr = 0 int oldThr = threshold; //新的容量,新的扩容因子 int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults //newCap = 16 newCap = DEFAULT_INITIAL_CAPACITY; //newThr = 16*0.75f =&gt; 扩容的临界值 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } //threshold = 16*0.75f threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //newTab 长度就是16 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;} put过程 排序 通过比较器接口java.util.Comparator 通过java.lang.Comparable[I] 面试题 List和Set区别 123451、List,Set都是继承自Collection接口2、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） 3.Set和List对比： Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 ArrayList和LinkedList区别 12345ArrayList基于动态数组实现的非线程安全的集合；LinkedList基于链表实现的非线程安全的集合。对于随机index访问的get和set方法，一般ArrayList的速度要优于LinkedList。因为ArrayList直接通过数组下标直接找到元素；LinkedList要移动指针遍历每个元素直到找到为止。新增和删除元素，一般LinkedList的速度要优于ArrayList。因为ArrayList在新增和删除元素时，可能扩容和复制数组；LinkedList实例化对象需要时间外，只需要修改指针即可。LinkedList集合不支持 高效的随机随机访问（RandomAccess）ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 ArrayList和Vector区别 12345678910111213141516171819（1）同步性： Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它 的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程 安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编 写线程安全的代码。（2）数据增长： ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需 要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存 储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原 来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。 ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提 供设置增长空间的方法。 HashSet和HashMap区别 1234(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.(3)当使用无参构造创建 HashSet对象时, 其实调用了 HashMap的无参构造创建了一个 HashMap对象, 所以 HashSet 的初始化容量也为16, 负载因子也为 0.75. TreeSet和TreeMap区别 1234567891011121314151617TreeMap 和 TreeSet 是 Java Collection Framework 的两个重要成员，其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 TreeMap 和TreeSet 实现的接口规范不同，但 TreeSet 底层是通过 TreeMap 来实现的（如同HashSet底层是是通过HashMap来实现的一样），因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法TreeSet和TreeMap的关系 与HashSet完全类似，TreeSet里面绝大部分方法都市直接调用TreeMap方法来实现的。相同点：TreeMap和TreeSet都是非同步集合，因此他们不能在多线程之间共享，不过可以使用方法Collections.synchroinzedMap()来实现同步运行速度都要比Hash集合慢，他们内部对元素的操作时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。TreeMap和TreeSet都是有序的集合，也就是说他们存储的值都是拍好序的。不同点：最主要的区别就是TreeSet和TreeMap分别实现Set和Map接口TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序）TreeSet中不能有重复对象，而TreeMap中可以存在TreeMap的底层采用红黑树的实现，完成数据有序的插入，排序。 HashMap和Hashtable[线程安全]区别 1234567线程安全性不同。HashMap线程不安全；Hashtable 中的方法是Synchronize的。key、value是否允许null。HashMap的key和value都是可以是null，key只允许一个null；Hashtable的key和value都不可为null。迭代器不同。HashMap的Iterator是fail-fast迭代器；Hashtable还使用了enumerator迭代器。hash的计算方式不同。HashMap计算了hash值；Hashtable使用了key的hashCode方法。默认初始大小和扩容方式不同。HashMap默认初始大小16，容量必须是2的整数次幂，扩容时将容量变为原来的2倍；Hashtable默认初始大小11，扩容时将容量变为原来的2倍加1。是否有contains方法。HashMap没有contains方法；Hashtable包含contains方法，类似于containsValue。父类不同。HashMap继承自AbstractMap；Hashtable继承自Dictionary。 Collection和Collections[集合工具类]区别 1234561、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。List，Set，Queue接口都继承Collection。直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。2、java.util.Collections 是一个包装类。 它包含有各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等），大多数方法都是用来处理线性表的。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 TreeSet 利用通过java.lang.Comparable[I] 对象去实现这个接口,并且重写comparaTo方法 利用构造器中可以传入一个比较器接口 =&gt; 更加灵活一点 123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;&gt;(comparator));} 泛型泛型符号 ? 12List&lt;?&gt; list = new ArrayList&lt;&gt;();list.add(null);//只能添加null K,V - 键,值 T - 类型 E - 元素 用法 泛型类 泛型方法 123456789101112public &lt;T&gt; void find(T t){ System.out.println(\"find:\"+t);}public &lt;T&gt; T get(T t){ System.out.println(\"find:\"+t); return t;}public static &lt;T&gt; void find2(T t){ System.out.println(\"find:\"+t);} 泛型好处 1、类型安全 泛型的主要目标是提高Java程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在非常高的层次上验证类型假设。没有泛型，这些假设就只存在于系统开发人员的头脑中。 通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误就可以在编译时被捕获了，而不是在运行时当作ClassCastException展示出来。将类型检查从运行时挪到编译时有助于Java开发人员更早、更容易地找到错误，并可提高程序的可靠性。 2、消除强制类型转换 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。尽管减少强制类型转换可以提高使用泛型类的代码的累赞程度，但是声明泛型变量时却会带来相应的累赞程度。在简单的程序中使用一次泛型变量不会降低代码累赞程度。但是对于多次使用泛型变量的大型程序来说，则可以累积起来降低累赞程度。所以泛型消除了强制类型转换之后，会使得代码加清晰和筒洁。 3、更高的运行效率 在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。 4、潜在的性能收益 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，Java系统开发人员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的JVM的优化带来可能。 应用123456789101112131415161718192021@Overriddepublic int save(Student s){ Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); tx.save(s); tx.commit();}@Overriddepublic Student getById(int id){ Session session = HibernateUtil.getSession(); Transaction tx = session.beginTransaction(); Student s = session.get(Student.class,id); tx.commit();} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//业务接口public interface ITeacherDao{ Teacher getById(int id); List&lt;Teacher&gt; loadAll(); int save(Teacher t);}//业务接口public interface IStudentDao{ Student getById(int id); List&lt;Student&gt; loadAll(); int save(Student s);}//考虑抽离出顶级的接口出来public interface IBaseDao&lt;T&gt; { T getById(int id); List&lt;T&gt; loadAll(); int save(T t);}//顶级接口的实现类public class BaseDaoImpl&lt;T&gt; implements IBaseDao&lt;T&gt; { @Override public T getById(int id) { //具体的实现 return null; } @Override public List&lt;T&gt; loadAll() { //具体的实现 return null; } @Override public int save(T t) { //具体的实现 return 0; }}//制定业务接口特有的功能public interface IStudentDao extends IBaseDao&lt;Student&gt;{ void test(); }//实现类public class StudentDaoImpl extends BaseDaoImpl&lt;Student&gt; implements IStudentDao { @Override public void test() { }} 指定上限和下限 指定下限 泛型参数可以是E,也可以是E的父类 1? super E 指定上限 泛型参数可以是E,也可以是E的子类 1? extends E 泛型是没有多态的.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://apelisun.github.io/tags/java/"},{"name":"collection","slug":"collection","permalink":"https://apelisun.github.io/tags/collection/"}]},{"title":"sql常用查询‘","slug":"sql常用查询‘","date":"2022-08-08T00:30:09.000Z","updated":"2022-08-10T03:51:58.422Z","comments":true,"path":"2022/08/08/sql常用查询‘/","link":"","permalink":"https://apelisun.github.io/2022/08/08/sql%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E2%80%98/","excerpt":"","text":"SQL查询练习 查询id=1课程比id=2课程成绩高的学生的信息[学生id和学生的姓名]及课程分数 1select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid join sc sc2 on sc1.sid=sc2.sid where sc1.cid=1 and sc2.cid=2 and sc1.score &gt;sc2.score; 查询同时存在1 课程和2课程的情况 1select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid join sc sc2 on sc1.sid=sc2.sid where sc2.cid =2 and sc1.cid=1 ; 查询存在1 课程但可能不存在2课程的情况 1select s.id,s.sname,sc1.score from student s join sc sc1 on s.id=sc1.sid where sc1.cid=1 ; 查询不存在1课程但存在2课程的情况 (不存在时显示为 null) 1select sc2.sid ,sc2.cid ,sc1.score 课程1,sc2.score 课程2 from (select *from sc where cid=1 ) sc1 RIGHT join (select *from sc where cid=2 ) sc2 on sc1.sid=sc2.sid where sc1.cid is null and sc2.cid=2; 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 1select s.id,s.sname,avg(sc.score) from student s join sc sc on s.id=sc.sid group by s.id having avg(sc.score)&gt;60 ; 查询在 SC 表存在成绩的学生信息 1select distinct s.id,s.sname from student s join sc sc on s.id=sc.sid where exists(select 1 from sc where score is not null); 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩 1select s.id ,s.sname,count(sc.cid),sum(sc.score) from student s join sc sc where sc.sid=s.id group by s.id; 查询「李」姓老师的数量 查询李老师的带过的学生的数量/授课的数量 123方法一.select (select count( c.id) '授课数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id where t.tname like '李%') 授课数,(select count( sc.sid) '学生数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id where t.tname like '李%') 带过的学生;select (select count(distinct c.id) '授课数' from teacher t join course c on c.tid=t.id join sc sc on sc.cid=c.id where t.tname like '李%') 授课数；方法2. select t.tname 老师姓名, count(distinct s.id) 学生数量,count(sc.cid) 授课数量 from student s join sc sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid where t.tname like '李%' group by t.id; 查询学过「张三」老师授课的同学的信息 1234方法一.select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid=(select c.id from teacher t left join course c on c.tid=t.id where t.tname='张三') 方法二.select distinct s.* from student s join sc sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid where t.tname='张三' ; 查询没有学全所有课程的同学的信息 12select s.id,s.sname from student s join sc sc on sc.sid=s.id GROUP BY s.id HAVING count(*)!=(select count(*) from course); 查询至少有一门课与学号为1的同学所学相同的同学的信息 12select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid in (select sc1.cid from sc sc1 where sc1.sid=1); 查询和id=1的同学学习的课程 完全相同的其他同学的信息（重要） - 非常重要,非常重要,非常重要,非常重要,非常重要! 1select s.id,s.sname,s.age,s.sex from student s where s.id in(select sc.sid from sc where sc.sid&lt;&gt;1 and sc.cid in(select sc.cid from sc where sc.sid=1) group by sc.sid having count(*)=(select count(*) from sc where sc.sid=1)); 查询没学过”张三”老师讲授的任一门课程的学生姓名 1select distinct s.id ID ,s.sname 学生姓名 from sc sc2 right join student s on s.id= sc2.sid where s.id not in(select sc.sid from sc where sc.cid=( select c.id from teacher t left join course c on c.tid=t.id where t.tname='张三')); 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 1select s.sname 姓名,s.id 学号,avg(sc.score) 平均分 from student s left join sc sc on s.id=sc.sid where sc.score&lt;60 group by s.id having count(*)&gt;=2 ; 检索” 01 “课程分数小于 60，按分数降序排列的学生信息 1select s.sname 姓名,s.id 学号,sc.score from student s left join sc sc on s.id=sc.sid where sc.score&lt;60 and sc.cid='01' order by 3 desc; 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 1select s.id ID,s.sname 姓名,coalesce(sc.cid,'未选') 课程编号, coalesce(sc.score,0) 分数,coalesce((select avg(sc2.score) from sc sc2 where sc2.sid=s.id),0) 平均分 from student s left join sc sc on s.id=sc.sid order by 5 desc; 查询各科成绩前三名的记录 1select s.id id,s.sname 姓名,sc.cid 课程号, sc.score 分数 from student s join sc sc on s.id=sc.sid where exists (select 1 from sc sc1 where sc.cid=sc1.cid and sc.score&lt;sc1.score having count(*)&lt;3) order by 4 desc, 3 desc; 查询每门课程被选修的学生数 1select c.id 课程号,c.cname 课程名,count(sc.sid) 学生数 from sc right join course c on c.id=sc.cid group by sc.cid; 查询出只选修两门课程的学生学号和姓名 1select s.id,s.sname from student s join sc sc on sc.sid=s.id group by s.id having count(sc.cid)=2; 查询男生、女生人数 1select s.sex 性别,count(s.sex) 人数 from student s group by s.sex; 查询名字中含有「风」字的学生信息 1select * from student s where s.sname like '%风%'; 查询同名同性学生名单，并统计同名同性人数 1select * from student s where exists (select 1 from student s2 where s2.sname=s.sname having count(*)&gt;=2); 查询 1990 年出生的学生名单 1select *from student s where year(s.age)=1990; 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 1select c.cname 课程名,sc.cid 课程id,avg(sc.score) 平均成绩 from course c left join sc sc on sc.cid=c.id group by c.id order by 3 desc,2; 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 1select s.id id,s.sname 姓名,coalesce(avg(sc.score),0) 平均成绩 from student s left join sc sc on s.id=sc.sid group by s.id having 平均成绩&gt;85; 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 1select s.id id,s.sname 姓名,sc.score 分数 from student s join sc sc on s.id=sc.sid join course c on c.id=sc.cid where c.cname='数学' and sc.score&lt;60; 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 1select s.id id,s.sname 姓名 ,sc.cid 课程名 ,sc.score 分数 from student s left join sc sc on s.id=sc.sid where sc.score&gt;70; 查询存在不及格的课程 1select sc.cid ,c.cname from sc sc join course c on c.id=sc.cid where sc.score&lt;60 group by sc.cid ; 查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名 1select s.id,s.sname from student s join sc sc on sc.sid=s.id where sc.cid=1 and sc.score&gt;80 group by s.id,s.sname; 求每门课程的学生人数 1select sc.cid ,count(sc.sid) from sc group by sc.cid ; 假设成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 1select s.id,s.sname,sc.score from student s join sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid and t.tname ='张三' where exists (select * from sc sc2 where sc.cid=sc2.cid and sc.score&lt;sc2.score having count(*)&lt;1) ; 假设成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 1select * from student s join sc on sc.sid=s.id join course c on c.id=sc.cid join teacher t on t.id=c.tid and t.tname ='张三' where exists (select * from sc sc2 where sc.cid=sc2.cid and sc.score&gt;=sc2.score having count(*)=(select count(sc3.cid) from sc sc3 where sc3.cid=sc.cid)) ; 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 12select s.id,s.sname,sc.cid,sc.score from student s join sc sc on sc.sid=s.id join sc sc2 on sc.sid=sc2.sid where sc.score=sc2.score andsc.cid!=sc2.cid; 统计每门课程的学生选修人数（超过 5 人的课程才统计） 1select sc.cid,count(*) from sc group by sc.cid having count(*)&gt;5 检索至少选修两门课程的学生学号 1select s.id from student s join sc on sc.sid=s.id group by s.id having count(sc.cid)&gt;=2; 查询选修了全部课程的学生信息 1select s.id from student s join sc on sc.sid=s.id group by s.id having count(sc.cid)=(select count(c.id) from course c );","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"interview","slug":"interview","permalink":"https://apelisun.github.io/tags/interview/"}]}],"categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://apelisun.github.io/tags/mysql/"},{"name":"procedure","slug":"procedure","permalink":"https://apelisun.github.io/tags/procedure/"},{"name":"B+树","slug":"B-树","permalink":"https://apelisun.github.io/tags/B-%E6%A0%91/"},{"name":"homework","slug":"homework","permalink":"https://apelisun.github.io/tags/homework/"},{"name":"meet DB","slug":"meet-DB","permalink":"https://apelisun.github.io/tags/meet-DB/"},{"name":"view","slug":"view","permalink":"https://apelisun.github.io/tags/view/"},{"name":"数据库基础","slug":"数据库基础","permalink":"https://apelisun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"name":"index","slug":"index","permalink":"https://apelisun.github.io/tags/index/"},{"name":"msql","slug":"msql","permalink":"https://apelisun.github.io/tags/msql/"},{"name":"area","slug":"area","permalink":"https://apelisun.github.io/tags/area/"},{"name":"java","slug":"java","permalink":"https://apelisun.github.io/tags/java/"},{"name":"collection","slug":"collection","permalink":"https://apelisun.github.io/tags/collection/"},{"name":"interview","slug":"interview","permalink":"https://apelisun.github.io/tags/interview/"}]}